<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="public, max-age=31536000, immutable">
    <meta http-equiv="Expires" content="Sat, 01 Jan 2025 00:00:00 GMT">
    <title>快乐8 AI预测游戏</title>
    <!-- 开发环境使用CDN版本，生产环境请使用构建版本 -->
    <!-- 生产环境构建命令: npm install && npm run build -->
    <!-- 然后替换为: <link href="dist/output.css" rel="stylesheet"> -->
    <script src="https://cdn.tailwindcss.com/3.4.17"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link href="styles_fixed.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <script>
        // 注册自定义标签插件
        Chart.register({
            id: 'customLabels',
            afterDatasetsDraw: function(chart) {
                const ctx = chart.ctx;
                chart.data.datasets.forEach(function(dataset, datasetIndex) {
                    const meta = chart.getDatasetMeta(datasetIndex);
                    if (!meta.hidden) {
                        meta.data.forEach(function(element, index) {
                            // 获取数据点的值
                            const value = dataset.data[index];
                            if (value !== null && value !== undefined) {
                                // 获取数据点的位置
                                const x = element.x;
                                const y = element.y;
                                  
                                // 设置样式 - 使用更大更清晰的字体
                                ctx.save();
                                ctx.font = 'bold 14px Arial';
                                ctx.fillStyle = chart.options.plugins.customLabels?.color || '#000'; // 使用插件配置中的颜色
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                  
                                // 直接在位置上绘制数字（替代圆点）
                                ctx.fillText(value, x, y);
                                  
                                ctx.restore();
                            }
                        });
                    }
                });
            }
        });
    </script>
    <script>
        // 全局状态管理
        const localState = {
            kl8HistoryData: [],
            frequencyData: [],
            predictionHistory: [],
            isDataLoaded: false,
            selectedNumbers: new Set(),
            positionCharts: {}
        };

        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#722ED1',
                        success: '#00B42A',
                        warning: '#FF7D00',
                        danger: '#F53F3F',
                        info: '#86909C',
                        light: '#F2F3F5',
                        dark: '#1D2129',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/css">
        /* Font Awesome 兼容性样式 */
        .fa-rotate-90, .fa-rotate-180, .fa-rotate-270, 
        .fa-flip-horizontal, .fa-flip-vertical {
            -ms-filter: none;
            filter: none;
            /* 为不支持-ms-filter的浏览器提供替代方案 */
            transform: none;
        }
        
        /* 为旋转类提供特定替代方案 */
        .fa-rotate-90 {
            transform: rotate(90deg);
        }
        .fa-rotate-180 {
            transform: rotate(180deg);
        }
        .fa-rotate-270 {
            transform: rotate(270deg);
        }
        .fa-flip-horizontal {
            transform: scale(-1, 1);
        }
        .fa-flip-vertical {
            transform: scale(1, -1);
        }
        /* 全局基础样式 */
        html {
            -webkit-text-size-adjust: 100%;
            -moz-text-size-adjust: 100%;
            text-size-adjust: 100%;
            /* 针对不支持text-size-adjust的浏览器 */
            -webkit-text-size-adjust: none;
            -ms-text-size-adjust: 100%;
        }
        
        /* 针对不支持text-size-adjust的浏览器提供后备方案 */
        @supports not (-webkit-text-size-adjust: 100%) {
            html {
                -webkit-text-size-adjust: none;
            }
            
            body {
                -webkit-text-size-adjust: none;
                -ms-text-size-adjust: none;
            }
        }
        
        /* 滚动条隐藏 */
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
            overflow: -moz-scrollbars-none;
        }
        
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        
        /* Safari兼容性 */
        @supports not (scrollbar-width: none) {
            .scrollbar-hide {
                overflow: -moz-scrollbars-none;
            }
        }
        
        /* 号码球样式 */
        .number-ball {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }
        
        .number-ball-selected {
            transform: scale(1.1);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        
        .card-hover {
            transition: all 0.3s;
        }
        
        .card-hover:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            transform: translateY(-4px);
        }
    </style>
<!-- 不再直接引入数据文件，而是通过Fetch API动态获取 -->
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- 顶部导航栏 -->
    <nav class="bg-white shadow-md">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fa fa-bar-chart text-primary text-2xl"></i>
                <h1 class="text-xl font-bold text-dark">快乐8 AI预测游戏</h1>
            </div>
            <div class="flex items-center space-x-4">
                <button id="saveBtn" class="hidden bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-save mr-1"></i> 保存预测
                </button>
                <button id="historyBtn" class="bg-secondary hover:bg-secondary/90 text-white px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-history mr-1"></i> 历史记录
                </button>
                <button id="kl8HistoryBtn" class="bg-success hover:bg-success/90 text-white px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-calendar-check-o mr-1"></i> 历史数据
                </button>
                <button id="numberFrequencyBtn" class="bg-info hover:bg-info/90 text-white px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-bar-chart mr-1"></i> 号码频率
                </button>
                <button id="aiUpdateBtn" class="bg-warning hover:bg-warning/90 text-white px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-refresh mr-1"></i> AI更新
                </button>
                <button id="dataCompareBtn" class="bg-danger hover:bg-danger/90 text-white px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-exchange mr-1"></i> 数据对比
                </button>
                <button id="predictResultCompareBtn" class="bg-secondary hover:bg-secondary/90 text-white px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-line-chart mr-1"></i> 预测结果对比
                </button>
                <button id="sameNumbersBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-clone mr-1"></i> 相同号码对比
                </button>
                <button id="helpBtn" class="bg-light hover:bg-gray-200 text-dark px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-question-circle mr-1"></i> 帮助
                </button>
            </div>
        </div>
    </nav>

    <!-- 主内容区 -->
    <main class="container mx-auto px-4 py-6">
        <!-- 状态和统计信息 -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
            <div class="bg-white rounded-lg shadow-sm p-5 card-hover">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold text-dark">历史数据</h3>
                    <span class="text-xs bg-primary/10 text-primary px-2 py-1 rounded">30期</span>
                </div>
                <p class="text-sm text-gray-500 mb-2">数据范围: <span id="dataRange" class="font-medium">2025239-2025268</span></p>
                <p class="text-sm text-gray-500">数据加载状态: <span id="dataStatus" class="text-warning">加载中...</span></p>
            </div>

            <div class="bg-white rounded-lg shadow-sm p-5 card-hover">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold text-dark">AI预测</h3>
                    <span class="text-xs bg-secondary/10 text-secondary px-2 py-1 rounded">v2.0</span>
                </div>
                <p class="text-sm text-gray-500 mb-2">预测方法: <select id="predictionMethod" class="text-sm border rounded px-2 py-1 focus:outline-none focus:ring-1 focus:ring-primary" title="选择AI预测方法">
                    <option value="smart">智能预测</option>
                    <option value="balanced">平衡分区</option>
                    <option value="frequency">频率预测</option>
                    <option value="positionTrend">位置走势预测</option>
                </select></p>
                <p class="text-sm text-gray-500">模型状态: <span id="modelStatus" class="text-warning">初始化中...</span></p>
            </div>

            <div class="bg-white rounded-lg shadow-sm p-5 card-hover">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold text-dark">统计信息</h3>
                    <span class="text-xs bg-success/10 text-success px-2 py-1 rounded">实时</span>
                </div>
                <p class="text-sm text-gray-500 mb-2">预测准确率: <span id="accuracyRate" class="font-medium">--%</span></p>
                <p class="text-sm text-gray-500">最近更新: <span id="lastUpdated" class="font-medium">--</span></p>
            </div>
        </div>

        <!-- 号码选择区域 -->
        <div class="bg-white rounded-lg shadow-sm p-5 mb-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-dark">号码选择</h2>
                <div class="flex space-x-2">
                    <button id="clearBtn" class="bg-gray-200 hover:bg-gray-300 text-dark px-3 py-1 rounded-md text-sm transition-all">
                        <i class="fa fa-refresh mr-1"></i> 清除
                    </button>
                    <button id="autoSelectBtn" class="bg-primary hover:bg-primary/90 text-white px-3 py-1 rounded-md text-sm transition-all">
                        <i class="fa fa-magic mr-1"></i> AI选号
                    </button>
                </div>
            </div>

            <!-- 号码球区域 -->
            <div id="numberBalls" class="grid grid-cols-8 sm:grid-cols-10 md:grid-cols-16 gap-2 mb-4"></div>
            
            <!-- 已选号码显示 -->
            <div class="bg-gray-50 rounded-lg p-3">
                <p class="text-sm text-gray-500 mb-2">已选号码 (<span id="selectedCount">0</span>/20):</p>
                <div id="selectedNumbers" class="flex flex-wrap gap-2 min-h-[60px]">
                    <p class="text-gray-400 italic text-sm">请选择20个号码或使用AI选号</p>
                </div>
            </div>
        </div>

        <!-- 图表和预测结果 -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            <!-- 频率分布图 -->
            <div class="bg-white rounded-lg shadow-sm p-5 col-span-1 lg:col-span-2 card-hover">
                <h2 class="text-lg font-semibold text-dark mb-4">号码频率分布</h2>
                <div class="relative h-[300px]">
                    <canvas id="frequencyChart"></canvas>
                </div>
            </div>
            
            <!-- 预测结果 -->
            <div class="bg-white rounded-lg shadow-sm p-5 card-hover">
                <h2 class="text-lg font-semibold text-dark mb-4">AI预测结果</h2>
                <div class="space-y-3">
                    <div class="bg-gray-50 p-3 rounded">
                        <p class="text-sm font-medium text-gray-700 mb-2">推荐号码:</p>
                        <div id="predictedNumbers" class="flex flex-wrap gap-1 max-h-[200px] overflow-y-auto scrollbar-hide">
                            <p class="text-gray-400 italic text-sm">点击AI选号生成推荐</p>
                        </div>
                    </div>
                    
                    <div class="bg-blue-50 p-3 rounded">
                        <p class="text-sm font-medium text-gray-700 mb-2">分区统计:</p>
                        <div class="space-y-2">
                            <div class="flex justify-between text-sm">
                                <span>01-20区:</span>
                                <span id="zone1Count" class="font-medium">0</span>
                            </div>
                            <div class="flex justify-between text-sm">
                                <span>21-40区:</span>
                                <span id="zone2Count" class="font-medium">0</span>
                            </div>
                            <div class="flex justify-between text-sm">
                                <span>41-60区:</span>
                                <span id="zone3Count" class="font-medium">0</span>
                            </div>
                            <div class="flex justify-between text-sm">
                                <span>61-80区:</span>
                                <span id="zone4Count" class="font-medium">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 历史预测记录 -->
        <div class="bg-white rounded-lg shadow-sm p-5 mb-6">
            <h2 class="text-lg font-semibold text-dark mb-4">历史预测记录</h2>
            <div class="overflow-x-auto">
                <table class="min-w-full">
                    <thead>
                        <tr class="bg-gray-50 border-b">
                            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">预测时间</th>
                            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">预测期号</th>
                            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">预测方法</th>
                            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">预测号码</th>
                            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">准确率</th>
                            <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">操作</th>
                        </tr>
                    </thead>
                    <tbody id="historyTableBody">
                        <tr>
                            <td colspan="6" class="px-4 py-8 text-center text-gray-400 italic">暂无预测记录</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="bg-white border-t py-4">
        <div class="container mx-auto px-4 text-center text-sm text-gray-500">
            <p>快乐8 AI预测游戏 - 仅供娱乐，理性购彩</p>
            <p class="mt-1">© 2025 AI预测系统 - 数据更新于 <span id="footerUpdateTime">--</span></p>
        </div>
    </footer>

    <!-- 模态框 -->
    <div id="historyModal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-lg max-w-3xl w-full max-h-[90vh] overflow-hidden flex flex-col">
            <div class="p-5 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold text-dark">预测历史记录</h2>
                <button id="closeHistoryModal" class="text-gray-400 hover:text-gray-600" title="关闭历史记录">
                    <i class="fa fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-5 overflow-y-auto flex-1">
                <div id="detailedHistory" class="space-y-4">
                    <!-- 历史记录将动态添加 -->
                </div>
            </div>
            <div class="p-5 border-t flex justify-end">
                <button id="exportHistoryBtn" class="bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-download mr-1"></i> 导出历史
                </button>
            </div>
        </div>
    </div>
    
    <!-- 调试按钮 -->
    <div class="fixed bottom-4 right-4 z-40">
        <button id="debugPredictionButton" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-full shadow-lg flex items-center">
            <i class="fa fa-bug mr-2"></i> 调试对比功能
        </button>
    </div>

    <!-- 历史数据模态框 -->
    <div id="kl8HistoryModal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-lg max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
            <div class="p-5 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold text-dark">快乐8最近30期开奖数据</h2>
                <button id="closeKl8HistoryModal" class="text-gray-400 hover:text-gray-600" title="关闭快乐8历史数据">
                    <i class="fa fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-5 overflow-y-auto flex-1">
                <div class="mb-4 text-right">
                    <p class="text-sm text-gray-500" id="kl8HistoryUpdateTime">数据更新时间: --</p>
                </div>
                
                <!-- 号码位置走势图（分页显示） -->
                <div class="bg-white rounded-lg shadow-sm border p-4 mb-6">
                    <div class="flex justify-between items-center mb-3">
                        <div class="flex items-center">
                            <h3 class="text-lg font-semibold mr-4">号码位置走势图</h3>
                            <button id="scrollLeftBtn" class="bg-gray-100 hover:bg-gray-200 px-3 py-1 rounded-l-md text-sm" disabled>
                                &lt;
                            </button>
                            <button id="scrollRightBtn" class="bg-gray-100 hover:bg-gray-200 px-3 py-1 rounded-r-md text-sm">
                                &gt;
                            </button>
                            <span id="chartPageInfo" class="ml-3 text-sm text-gray-500">第 1 页</span>
                        </div>
                        <div class="flex items-center space-x-3">
                            <select id="positionChartPeriods" class="border rounded-md px-3 py-1.5 text-sm" aria-label="选择走势图显示期数">
                                <option value="10">最近10期</option>
                                <option value="20">最近20期</option>
                                <option value="30">最近30期</option>
                                <option value="47" selected>最近47期</option>
                                <option value="all">所有期数</option>
                            </select>
                            <button id="updateAllChartsBtn" class="bg-primary hover:bg-primary/90 text-white px-3 py-1.5 rounded-md text-sm transition-all">
                                <i class="fa fa-refresh mr-1"></i> 更新所有
                            </button>
                        </div>
                    </div>
                    
                    <!-- 分页标签 -->
                    <div class="flex mb-4 overflow-x-auto pb-2 space-x-1">
                        <button class="position-page-btn px-3 py-1.5 rounded-md text-sm border ${page === 1 ? 'bg-primary text-white border-primary' : 'border-gray-300 text-gray-700 hover:bg-gray-50'}" data-page="1">
                            位置 1-5
                        </button>
                        <button class="position-page-btn px-3 py-1.5 rounded-md text-sm border ${page === 2 ? 'bg-primary text-white border-primary' : 'border-gray-300 text-gray-700 hover:bg-gray-50'}" data-page="2">
                            位置 6-10
                        </button>
                        <button class="position-page-btn px-3 py-1.5 rounded-md text-sm border ${page === 3 ? 'bg-primary text-white border-primary' : 'border-gray-300 text-gray-700 hover:bg-gray-50'}" data-page="3">
                            位置 11-15
                        </button>
                        <button class="position-page-btn px-3 py-1.5 rounded-md text-sm border ${page === 4 ? 'bg-primary text-white border-primary' : 'border-gray-300 text-gray-700 hover:bg-gray-50'}" data-page="4">
                            位置 16-20
                        </button>
                        <button class="position-page-btn px-3 py-1.5 rounded-md text-sm border ${page === 5 ? 'bg-primary text-white border-primary' : 'border-gray-300 text-gray-700 hover:bg-gray-50'}" data-page="5">
                            末位号码
                        </button>
                    </div>
                    
                    <!-- 图表容器 - 每页显示5个图表 -->
                    <div class="space-y-6">
                        <!-- 第1页：位置1-5 -->
                        <div id="positionChartsPage1">
                            <!-- 位置1 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">首个号码（位置1）</h4>
                                <canvas id="positionChart1"></canvas>
                            </div>
                            <!-- 位置2 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第二个号码（位置2）</h4>
                                <canvas id="positionChart2"></canvas>
                            </div>
                            <!-- 位置3 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第三个号码（位置3）</h4>
                                <canvas id="positionChart3"></canvas>
                            </div>
                            <!-- 位置4 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第四个号码（位置4）</h4>
                                <canvas id="positionChart4"></canvas>
                            </div>
                            <!-- 位置5 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第五个号码（位置5）</h4>
                                <canvas id="positionChart5"></canvas>
                            </div>
                        </div>
                        
                        <!-- 第2页：位置6-10 (默认隐藏) -->
                        <div id="positionChartsPage2" class="hidden">
                            <!-- 位置6 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第六个号码（位置6）</h4>
                                <canvas id="positionChart6"></canvas>
                            </div>
                            <!-- 位置7 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第七个号码（位置7）</h4>
                                <canvas id="positionChart7"></canvas>
                            </div>
                            <!-- 位置8 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第八个号码（位置8）</h4>
                                <canvas id="positionChart8"></canvas>
                            </div>
                            <!-- 位置9 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第九个号码（位置9）</h4>
                                <canvas id="positionChart9"></canvas>
                            </div>
                            <!-- 位置10 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第十个号码（位置10）</h4>
                                <canvas id="positionChart10"></canvas>
                            </div>
                        </div>
                        
                        <!-- 第3页：位置11-15 (默认隐藏) -->
                        <div id="positionChartsPage3" class="hidden">
                            <!-- 位置11 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第十一个号码（位置11）</h4>
                                <canvas id="positionChart11"></canvas>
                            </div>
                            <!-- 位置12 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第十二个号码（位置12）</h4>
                                <canvas id="positionChart12"></canvas>
                            </div>
                            <!-- 位置13 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第十三个号码（位置13）</h4>
                                <canvas id="positionChart13"></canvas>
                            </div>
                            <!-- 位置14 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第十四个号码（位置14）</h4>
                                <canvas id="positionChart14"></canvas>
                            </div>
                            <!-- 位置15 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第十五个号码（位置15）</h4>
                                <canvas id="positionChart15"></canvas>
                            </div>
                        </div>
                        
                        <!-- 第4页：位置16-20 (默认隐藏) -->
                        <div id="positionChartsPage4" class="hidden">
                            <!-- 位置16 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第十六个号码（位置16）</h4>
                                <canvas id="positionChart16"></canvas>
                            </div>
                            <!-- 位置17 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第十七个号码（位置17）</h4>
                                <canvas id="positionChart17"></canvas>
                            </div>
                            <!-- 位置18 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第十八个号码（位置18）</h4>
                                <canvas id="positionChart18"></canvas>
                            </div>
                            <!-- 位置19 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第十九个号码（位置19）</h4>
                                <canvas id="positionChart19"></canvas>
                            </div>
                            <!-- 位置20 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">第二十个号码（位置20）</h4>
                                <canvas id="positionChart20"></canvas>
                            </div>
                        </div>
                        
                        <!-- 第5页：末位号码 (默认隐藏) -->
                        <div id="positionChartsPage5" class="hidden">
                            <!-- 末位0 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">末位为0的号码位置</h4>
                                <canvas id="lastDigitChart0"></canvas>
                            </div>
                            <!-- 末位1 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">末位为1的号码位置</h4>
                                <canvas id="lastDigitChart1"></canvas>
                            </div>
                            <!-- 末位2 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">末位为2的号码位置</h4>
                                <canvas id="lastDigitChart2"></canvas>
                            </div>
                            <!-- 末位3 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">末位为3的号码位置</h4>
                                <canvas id="lastDigitChart3"></canvas>
                            </div>
                            <!-- 末位4 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">末位为4的号码位置</h4>
                                <canvas id="lastDigitChart4"></canvas>
                            </div>
                            <!-- 末位5 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">末位为5的号码位置</h4>
                                <canvas id="lastDigitChart5"></canvas>
                            </div>
                            <!-- 末位6 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">末位为6的号码位置</h4>
                                <canvas id="lastDigitChart6"></canvas>
                            </div>
                            <!-- 末位7 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">末位为7的号码位置</h4>
                                <canvas id="lastDigitChart7"></canvas>
                            </div>
                            <!-- 末位8 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">末位为8的号码位置</h4>
                                <canvas id="lastDigitChart8"></canvas>
                            </div>
                            <!-- 末位9 -->
                            <div class="h-60 mb-4">
                                <h4 class="text-base font-medium mb-2">末位为9的号码位置</h4>
                                <canvas id="lastDigitChart9"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="kl8HistoryContent" class="space-y-6">
                    <!-- 历史数据将动态加载 -->
                    <div class="flex items-center justify-center h-40 text-gray-400">
                        <i class="fa fa-spinner fa-spin mr-2"></i> 加载中...
                    </div>
                </div>
            </div>
            <div class="p-5 border-t flex justify-end">
                <button id="editKl8HistoryBtn" class="bg-warning hover:bg-warning/90 text-white px-4 py-2 rounded-md transition-all mr-2">
                    <i class="fa fa-pencil mr-1"></i> 编辑数据
                </button>
                <button id="refreshKl8HistoryBtn" class="bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-md transition-all mr-2">
                    <i class="fa fa-refresh mr-1"></i> 刷新数据
                </button>
                <button id="closeKl8HistoryBtn" class="bg-light hover:bg-gray-200 text-dark px-4 py-2 rounded-md transition-all">
                    关闭
                </button>
            </div>
        </div>
    </div>

    <!-- 历史数据编辑模态框 -->
    <div id="kl8HistoryEditModal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-lg max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
            <div class="p-5 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold text-dark">编辑快乐8历史数据</h2>
                <button id="closeKl8HistoryEditModal" class="text-gray-400 hover:text-gray-600" title="关闭历史数据编辑">
                    <i class="fa fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-5 overflow-y-auto flex-1">
                <div id="kl8HistoryEditContent" class="space-y-6">
                    <!-- 编辑表单将动态加载 -->
                    <div class="flex items-center justify-center h-40 text-gray-400">
                        <i class="fa fa-spinner fa-spin mr-2"></i> 加载中...
                    </div>
                </div>
            </div>
            <div class="p-5 border-t flex justify-end">
                <button id="importKl8HistoryBtn" class="bg-secondary hover:bg-secondary/90 text-white px-4 py-2 rounded-md transition-all mr-2">
                    <i class="fa fa-upload mr-1"></i> 导入数据
                </button>
                <button id="addNewKl8HistoryBtn" class="bg-info hover:bg-info/90 text-white px-4 py-2 rounded-md transition-all mr-2">
                    <i class="fa fa-plus mr-1"></i> 添加数据
                </button>
                <input type="file" id="kl8HistoryFileInput" accept=".json" class="hidden" title="导入历史数据JSON文件" aria-label="导入历史数据">
                <button id="saveEditedKl8HistoryBtn" class="bg-success hover:bg-success/90 text-white px-4 py-2 rounded-md transition-all mr-2">
                    <i class="fa fa-save mr-1"></i> 保存修改
                </button>
                <button id="cancelEditKl8HistoryBtn" class="bg-light hover:bg-gray-200 text-dark px-4 py-2 rounded-md transition-all">
                    取消
                </button>
            </div>
        </div>
    </div>

    <!-- 添加新的历史数据模态框 -->
    <div id="addKl8HistoryModal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-lg max-w-2xl w-full max-h-[90vh] overflow-hidden flex flex-col">
            <div class="p-5 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold text-dark">添加快乐8历史数据</h2>
                <button id="closeAddKl8HistoryModal" class="text-gray-400 hover:text-gray-600" title="关闭添加历史数据">
                    <i class="fa fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-5 overflow-y-auto flex-1">
                <div class="space-y-6">
                    <div class="mb-4 p-3 bg-blue-50 rounded-md text-sm text-blue-700">
                        <i class="fa fa-info-circle mr-1"></i> 请输入新的期号和20个开奖号码，用空格分隔
                    </div>
                    
                    <div class="space-y-4">
                        <div>
                            <label for="newPeriod" class="block text-sm font-medium text-gray-700 mb-1">期号</label>
                            <input type="text" id="newPeriod" class="w-full border rounded-md px-3 py-2" placeholder="请输入期号，例如：2025268">
                        </div>
                        
                        <div>
                            <label for="newNumbers" class="block text-sm font-medium text-gray-700 mb-1">开奖号码</label>
                            <textarea id="newNumbers" rows="4" class="w-full border rounded-md px-3 py-2" placeholder="请输入20个号码，用空格分隔，例如：01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20"></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <div class="p-5 border-t flex justify-end">
                <button id="confirmAddKl8HistoryBtn" class="bg-success hover:bg-success/90 text-white px-4 py-2 rounded-md transition-all mr-2">
                    <i class="fa fa-check mr-1"></i> 确认添加
                </button>
                <button id="cancelAddKl8HistoryBtn" class="bg-light hover:bg-gray-200 text-dark px-4 py-2 rounded-md transition-all">
                    取消
                </button>
            </div>
        </div>
    </div>

    <!-- 号码频率分布模态框 -->
    <div id="numberFrequencyModal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-lg max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
            <div class="p-5 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold text-dark">号码频率分布</h2>
                <button id="closeNumberFrequencyModal" class="text-gray-400 hover:text-gray-600" title="关闭号码频率">
                    <i class="fa fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-5 overflow-y-auto flex-1">
                <div class="mb-4">
                    <p class="text-sm text-gray-500 mb-2">统计范围: <span id="frequencyDataRange" class="font-medium">--</span></p>
                    <p class="text-sm text-gray-500">总期数: <span id="totalPeriods" class="font-medium">0</span></p>
                </div>
                <div id="frequencyChartContainer" class="mb-6">
                    <div class="relative h-[300px]">
                        <canvas id="numberFrequencyChart"></canvas>
                    </div>
                </div>
                <div id="numberFrequencyTable" class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">号码</th>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">出现次数</th>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">出现频率</th>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">频率分布</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            <!-- 频率数据将动态加载 -->
                            <tr>
                                <td colspan="4" class="px-6 py-10 text-center text-gray-400">
                                    <i class="fa fa-spinner fa-spin mr-2"></i> 加载中...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="p-5 border-t flex justify-end">
                <button id="closeNumberFrequencyBtn" class="bg-light hover:bg-gray-200 text-dark px-4 py-2 rounded-md transition-all">
                    关闭
                </button>
            </div>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-lg max-w-2xl w-full max-h-[90vh] overflow-hidden flex flex-col">
            <div class="p-5 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold text-dark">使用帮助</h2>
                <button id="closeHelpModal" class="text-gray-400 hover:text-gray-600" title="关闭帮助">
                    <i class="fa fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-5 overflow-y-auto flex-1">
                <div class="space-y-4">
                    <h3 class="text-lg font-semibold">1. 关于快乐8 AI预测游戏</h3>
                    <p class="text-gray-700">本系统基于最近300期快乐8历史数据，使用AI算法分析号码出现频率和规律，帮助用户选择可能的中奖号码。</p>
                    
                    <h3 class="text-lg font-semibold">2. 如何使用</h3>
                    <ul class="list-disc list-inside text-gray-700 space-y-2">
                        <li>点击"AI选号"按钮，系统会自动根据选择的预测方法生成20个推荐号码</li>
                        <li>也可以手动点击号码球进行选择，最多选择20个号码</li>
                        <li>点击"清除"按钮可以重新选择</li>
                        <li>点击"保存预测"按钮可以将当前预测结果保存到历史记录中</li>
                    </ul>
                    
                    <h3 class="text-lg font-semibold">3. 预测方法说明</h3>
                    <ul class="list-disc list-inside text-gray-700 space-y-2">
                        <li><span class="font-medium">智能预测：</span>结合频率、间隔和最近趋势进行综合分析</li>
                        <li><span class="font-medium">平衡分区：</span>确保每个号码分区(01-20, 21-40, 41-60, 61-80)都有一定数量的号码</li>
                        <li><span class="font-medium">频率预测：</span>完全基于历史出现频率选择号码</li>
                        <li><span class="font-medium">历史相似性预测：</span>结合历史数据相同号码对比和号码频率分布进行分析预测</li>
                    </ul>
                    
                    <h3 class="text-lg font-semibold">4. 免责声明</h3>
                    <p class="text-gray-700">本系统仅供娱乐和参考，不保证中奖。请理性购彩，量力而行。</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 更新localState对象，添加额外的属性
        Object.assign(localState, {
            model: null,
            lastPrediction: null,
            historyUpdateInterval: null, // 添加定时器引用
            lastDigitCharts: {} // 添加末位号码图表对象
        });

        // 启动历史数据自动更新
        function startHistoryAutoUpdate() {
            // 如果已经有定时器在运行，先清除它
            if (localState.historyUpdateInterval) {
                clearInterval(localState.historyUpdateInterval);
            }
            
            // 设置定时器，每30秒刷新一次数据
            localState.historyUpdateInterval = setInterval(() => {
                // 检查历史数据模态框是否可见
                if (!document.getElementById('kl8HistoryModal').classList.contains('hidden')) {
                    loadKl8HistoryData();
                }
            }, 30000); // 30秒
        }

        // 绑定事件监听器
        function bindEventListeners() {
            // 清除按钮点击事件
            document.getElementById('clearBtn').addEventListener('click', function() {
                clearSelectedNumbers();
            });
            
            // AI选号按钮点击事件
            document.getElementById('autoSelectBtn').addEventListener('click', function() {
                const method = document.getElementById('predictionMethod').value;
                const predictedNumbers = predictNumbers(method);
                
                // 自动保存预测记录，但避免重复保存相同期号的记录
                localState.selectedNumbers = new Set(predictedNumbers);
                
                // 获取当前预测期号
                const currentPeriod = localState.lastPrediction.period;
                
                // 检查是否已存在相同期号的预测记录
                const existingIndex = localState.predictionHistory.findIndex(p => p.period === currentPeriod);
                
                if (existingIndex !== -1) {
                    // 如果存在相同期号的记录，则更新它而不是创建新记录
                    const updatedPrediction = {
                        ...localState.predictionHistory[existingIndex],
                        timestamp: new Date().toLocaleString('zh-CN'),
                        method: method,
                        numbers: Array.from(localState.selectedNumbers).sort((a, b) => a - b)
                    };
                    
                    localState.predictionHistory[existingIndex] = updatedPrediction;
                    savePredictionHistory();
                    updateHistoryTable();
                    showNotification('预测记录已更新', 'success');
                } else {
                    // 如果不存在相同期号的记录，则创建新记录
                    savePrediction();
                }
            });
            
            // 预测方法选择事件
            document.getElementById('predictionMethod').addEventListener('change', function() {
                // 更新预测方法选择，但不立即重新预测
                if (localState.isDataLoaded) {
                    showNotification('预测方法已切换', 'info');
                }
            });
            
            // 历史记录模态框相关事件
            document.getElementById('closeHistoryModal').addEventListener('click', function() {
                document.getElementById('historyModal').classList.add('hidden');
            });
            
            document.getElementById('exportHistoryBtn').addEventListener('click', function() {
                exportHistory();
            });
            
            // 快乐8历史数据模态框相关事件
            document.getElementById('closeKl8HistoryModal').addEventListener('click', function() {
                document.getElementById('kl8HistoryModal').classList.add('hidden');
            });
            
            document.getElementById('closeKl8HistoryBtn').addEventListener('click', function() {
                document.getElementById('kl8HistoryModal').classList.add('hidden');
            });
            
            document.getElementById('refreshKl8HistoryBtn').addEventListener('click', function() {
                loadKl8HistoryData();
                showNotification('正在刷新历史数据...', 'info');
            });
            
            // 使用ID绑定特定按钮的事件，避免混淆
            // 历史记录按钮
            document.getElementById('historyBtn').addEventListener('click', function() {
                if (localState.predictionHistory.length === 0) {
                    showNotification('暂无历史记录', 'info');
                } else {
                    updateHistoryTable();
                    document.getElementById('historyModal').classList.remove('hidden');
                }
            });
            
            // 历史数据按钮
            document.getElementById('kl8HistoryBtn').addEventListener('click', function() {
                document.getElementById('kl8HistoryModal').classList.remove('hidden');
                if (localState.kl8HistoryData.length === 0) {
                    loadKl8HistoryData();
                } else {
                    renderKl8HistoryData();
                }
            });
            
            // 号码频率按钮
            document.getElementById('numberFrequencyBtn').addEventListener('click', function() {
                document.getElementById('numberFrequencyModal').classList.remove('hidden');
                if (localState.kl8HistoryData.length === 0) {
                    loadKl8HistoryData().then(() => {
                        renderNumberFrequency();
                    });
                } else {
                    renderNumberFrequency();
                }
            });
            
            // 号码频率模态框关闭事件
            document.getElementById('closeNumberFrequencyModal').addEventListener('click', function() {
                document.getElementById('numberFrequencyModal').classList.add('hidden');
            });
            
            document.getElementById('closeNumberFrequencyBtn').addEventListener('click', function() {
                document.getElementById('numberFrequencyModal').classList.add('hidden');
            });

            // 编辑历史数据按钮
            document.getElementById('editKl8HistoryBtn').addEventListener('click', function() {
                document.getElementById('kl8HistoryEditModal').classList.remove('hidden');
                renderKl8HistoryEditForm();
            });

            // 关闭历史数据编辑模态框
            document.getElementById('closeKl8HistoryEditModal').addEventListener('click', function() {
                document.getElementById('kl8HistoryEditModal').classList.add('hidden');
            });

            // 取消编辑历史数据
            document.getElementById('cancelEditKl8HistoryBtn').addEventListener('click', function() {
                document.getElementById('kl8HistoryEditModal').classList.add('hidden');
            });

            // 保存编辑后的历史数据
            document.getElementById('saveEditedKl8HistoryBtn').addEventListener('click', function() {
                saveEditedKl8HistoryData();
            });

            // 添加新数据按钮
            document.getElementById('addNewKl8HistoryBtn').addEventListener('click', function() {
                document.getElementById('addKl8HistoryModal').classList.remove('hidden');
                // 重置表单
                document.getElementById('newPeriod').value = '';
                document.getElementById('newNumbers').value = '';
            });

            // 关闭添加数据模态框
            document.getElementById('closeAddKl8HistoryModal').addEventListener('click', function() {
                document.getElementById('addKl8HistoryModal').classList.add('hidden');
            });

            // 取消添加数据
            document.getElementById('cancelAddKl8HistoryBtn').addEventListener('click', function() {
                document.getElementById('addKl8HistoryModal').classList.add('hidden');
            });

            // 确认添加数据
            document.getElementById('confirmAddKl8HistoryBtn').addEventListener('click', function() {
                addNewKl8HistoryData();
            });
            
            // 保存预测按钮
            document.getElementById('saveBtn').addEventListener('click', savePrediction);
            
            // 号码球点击事件委托
            document.getElementById('numberBalls').addEventListener('click', function(e) {
                if (e.target.classList.contains('number-ball')) {
                    const number = parseInt(e.target.dataset.number);
                    toggleNumberSelection(number);
                }
            });
        }
        
        // 创建号码球
            createNumberBalls();
            
            // 绑定事件监听器
            bindEventListeners();
            
            // 模拟数据加载
            simulateDataLoading();

        // 创建号码球
        function createNumberBalls() {
            const container = document.getElementById('numberBalls');
            
            for (let i = 1; i <= 80; i++) {
                const ball = document.createElement('div');
                ball.className = 'number-ball bg-gray-300 text-dark';
                ball.dataset.number = i;
                ball.textContent = i;
                
                // 设置不同区间的基础颜色
                if (i <= 20) {
                    ball.classList.add('bg-blue-400');
                } else if (i <= 40) {
                    ball.classList.add('bg-green-400');
                } else if (i <= 60) {
                    ball.classList.add('bg-yellow-400');
                } else {
                    ball.classList.add('bg-red-400');
                }
                
                ball.addEventListener('click', function() {
                    toggleNumberSelection(i);
                });
                
                container.appendChild(ball);
            }
        }

        // 切换号码选择状态
        function toggleNumberSelection(number) {
            const ball = document.querySelector('.number-ball[data-number="' + number + '"]');
            
            if (localState.selectedNumbers.has(number)) {
                // 取消选择
                localState.selectedNumbers.delete(number);
                ball.classList.remove('number-ball-selected');
            } else {
                // 选择号码（最多20个）
                if (localState.selectedNumbers.size >= 20) {
                    showNotification('最多只能选择20个号码', 'warning');
                    return;
                }
                
                localState.selectedNumbers.add(number);
                ball.classList.add('number-ball-selected');
            }

            updateSelectedNumbersDisplay();
        }

        // 更新已选号码显示
        function updateSelectedNumbersDisplay() {
            const container = document.getElementById('selectedNumbers');
            const countElement = document.getElementById('selectedCount');
            
            // 更新计数
            countElement.textContent = localState.selectedNumbers.size;
            
            // 清空容器
            container.innerHTML = '';
            
            if (localState.selectedNumbers.size === 0) {
                container.innerHTML = '<p class="text-gray-400 italic text-sm">请选择20个号码或使用AI选号</p>';
                return;
            }
            
            // 显示已选号码
            const sortedNumbers = Array.from(localState.selectedNumbers).sort((a, b) => a - b);
            
            sortedNumbers.forEach(number => {
                const ball = document.createElement('div');
                ball.className = 'number-ball bg-primary number-ball-selected';
                ball.textContent = number;
                
                // 添加移除按钮
                const removeBtn = document.createElement('span');
                removeBtn.className = 'absolute text-xs -top-1 -right-1 bg-white text-danger w-4 h-4 rounded-full flex items-center justify-center';
                removeBtn.textContent = '×';
                removeBtn.style.fontSize = '10px';
                ball.style.position = 'relative';
                ball.appendChild(removeBtn);
                
                removeBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleNumberSelection(number);
                });
                
                container.appendChild(ball);
            });
            
            // 显示保存按钮
            document.getElementById('saveBtn').classList.remove('hidden');
        }

        // 模拟数据加载
        function simulateDataLoading() {
            setTimeout(() => {
                // 模拟加载历史数据
                document.getElementById('dataStatus').textContent = '已加载';
                document.getElementById('dataStatus').classList.remove('text-warning');
                document.getElementById('dataStatus').classList.add('text-success');
                
                // 模拟初始化AI模型
                setTimeout(() => {
                    document.getElementById('modelStatus').textContent = '已初始化';
                    document.getElementById('modelStatus').classList.remove('text-warning');
                    document.getElementById('modelStatus').classList.add('text-success');
                    
                    // 设置最近更新时间
                    const now = new Date();
                    const formattedTime = now.toLocaleString('zh-CN');
                    document.getElementById('lastUpdated').textContent = formattedTime;
                    document.getElementById('footerUpdateTime').textContent = formattedTime;
                    
                    // 生成模拟频率数据
                    generateMockFrequencyData();
                    
                    // 设置模拟准确率
                    document.getElementById('accuracyRate').textContent = '58.00%';
                    
                    // 设置状态
                    localState.isDataLoaded = true;
                    
                    // 加载本地存储的历史记录
                    loadPredictionHistory();
                    
                    // 初始化图表（在数据加载完成后）
                    initCharts();
                    
                    // 更新频率图表
                    updateFrequencyChart();
                    
                    showNotification('数据加载完成，可以开始使用AI选号功能', 'success');
                }, 1000);
            }, 1500);
        }

        // 生成模拟频率数据
        function generateMockFrequencyData() {
            localState.frequencyData = [];
            
            // 为1-80的每个号码生成一个随机频率（基于真实情况的模拟）
            for (let i = 1; i <= 80; i++) {
                // 生成一个有偏差的随机数，让某些号码出现频率更高
                let baseFrequency = Math.random() * 50 + 30;
                
                // 调整一些特定号码的频率，使其更符合现实分布
                if (i % 7 === 0 || i % 11 === 0) {
                    baseFrequency += 10;
                }
                
                localState.frequencyData.push({
                    number: i,
                    frequency: Math.floor(baseFrequency)
                });
            }
            
            // 按频率排序
            localState.frequencyData.sort((a, b) => b.frequency - a.frequency);
        }

        // 初始化图表
            function initCharts() {
                const ctx = document.getElementById('frequencyChart').getContext('2d');
                
                // 创建图表实例
                localState.frequencyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: '出现频率',
                        data: [],
                        backgroundColor: '#165DFF',
                        borderColor: '#165DFF',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return '出现次数: ' + context.raw;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '号码'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '出现次数'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // 更新频率图表
        function updateFrequencyChart() {
            if (!localState.frequencyChart || localState.frequencyData.length === 0) {
                return;
            }
            
            // 只显示前30个高频号码
            const topNumbers = localState.frequencyData.slice(0, 30);
            
            localState.frequencyChart.data.labels = topNumbers.map(item => item.number);
            localState.frequencyChart.data.datasets[0].data = topNumbers.map(item => item.frequency);
            
            // 更新图表
            localState.frequencyChart.update();
        }

        // 获取下一期期号
        function getNextPeriodNumber() {
            if (!localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
                // 如果没有历史数据，返回默认值
                return '2025272';
            }
            
            const latestPeriod = localState.kl8HistoryData[0].period;
            // 期号格式为YYYYDDD，如2025271表示2025年的第271期
            const nextPeriod = (parseInt(latestPeriod) + 1).toString();
            return nextPeriod;
        }
        
        // AI预测号码
        function predictNumbers(method = 'smart') {
            if (!localState.isDataLoaded) {
                showNotification('数据尚未加载完成，请稍后再试', 'warning');
                return [];
            }
            
            let predictedNumbers = [];
            
            switch (method) {
                case 'frequency':
                    // 基于频率预测
                    predictedNumbers = localState.frequencyData.slice(0, 20).map(item => item.number);
                    break;
                case 'balanced':
                    // 平衡分区预测
                    predictedNumbers = balancedPrediction();
                    break;
                case 'positionTrend':
                    // 基于位置走势预测
                    predictedNumbers = positionTrendPrediction();
                    break;
                case 'smart':
                default:
                    // 智能预测（结合多种因素）
                    predictedNumbers = smartPrediction();
                    break;
            }
            
            // 排序
            predictedNumbers.sort((a, b) => a - b);
            
            // 生成下一期期号
            const nextPeriod = getNextPeriodNumber();
            
            // 保存预测结果
            localState.lastPrediction = {
                numbers: predictedNumbers,
                method: method,
                timestamp: new Date().toLocaleString('zh-CN'),
                period: nextPeriod
            };
            
            // 更新UI
            updatePredictedNumbersDisplay(predictedNumbers, nextPeriod);
            
            return predictedNumbers;
        }
        
        // 基于位置走势的预测算法（增强版）
        // 分析每个位置的历史走势，预测下一期可能出现的号码
        function positionTrendPrediction() {
            console.log('执行增强版基于位置走势的预测算法...');
            
            if (!localState.kl8HistoryData || localState.kl8HistoryData.length < 10) {
                console.error('历史数据不足，无法进行位置走势分析');
                return [];
            }
            
            const predictedNumbers = new Map(); // 使用Map存储预测号码及其置信度
            const numPositions = 20; // 快乐8有20个位置
            const recentPeriods = Math.min(30, localState.kl8HistoryData.length); // 使用最多30期历史数据
            
            // 计算全局位置统计信息
            const globalStats = calculateGlobalPositionStats();
            
            // 对每个位置进行独立分析
            for (let position = 1; position <= numPositions; position++) {
                // 获取该位置最近几期的号码
                const positionHistory = [];
                for (let i = 0; i < recentPeriods; i++) {
                    const periodData = localState.kl8HistoryData[i];
                    if (periodData.numbers && periodData.numbers.length >= position) {
                        positionHistory.push(parseInt(periodData.numbers[position - 1]));
                    }
                }
                
                if (positionHistory.length < 5) continue; // 数据不足时跳过
                
                // 使用增强算法分析位置走势并预测下一个号码
                const predictedNum = enhancedPredictNextNumberForPosition(
                    positionHistory, 
                    position, 
                    globalStats, 
                    recentPeriods
                );
                
                if (predictedNum && predictedNum >= 1 && predictedNum <= 80) {
                    // 计算置信度分数（基于历史数据量和趋势强度）
                    const confidence = calculateConfidenceScore(positionHistory, position, globalStats);
                    
                    // 如果该号码已经被预测，保留置信度更高的
                    if (!predictedNumbers.has(predictedNum) || confidence > predictedNumbers.get(predictedNum)) {
                        predictedNumbers.set(predictedNum, confidence);
                    }
                }
            }
            
            // 按置信度排序
            const sortedNumbers = Array.from(predictedNumbers.entries())
                .sort(([,confA], [,confB]) => confB - confA)
                .map(([num]) => num);
            
            // 如果预测结果不足20个号码，使用频率数据补充
            if (sortedNumbers.length < 20 && localState.frequencyData) {
                let freqIndex = 0;
                while (sortedNumbers.length < 20 && freqIndex < localState.frequencyData.length) {
                    const num = localState.frequencyData[freqIndex].number;
                    if (!sortedNumbers.includes(num)) {
                        sortedNumbers.push(num);
                    }
                    freqIndex++;
                }
            }
            
            // 转换为数组并排序
            const result = sortedNumbers.slice(0, 20).sort((a, b) => a - b);
            console.log('增强的位置走势预测完成，选中号码:', result);
            return result;
        }
        
        // 计算全局位置统计信息
        function calculateGlobalPositionStats() {
            const stats = {};
            const numPositions = 20;
            
            for (let position = 1; position <= numPositions; position++) {
                const positionNumbers = [];
                
                // 收集该位置的所有历史号码
                for (let i = 0; i < localState.kl8HistoryData.length; i++) {
                    const periodData = localState.kl8HistoryData[i];
                    if (periodData.numbers && periodData.numbers.length >= position) {
                        positionNumbers.push(parseInt(periodData.numbers[position - 1]));
                    }
                }
                
                if (positionNumbers.length > 0) {
                    // 计算该位置的统计信息
                    const avg = positionNumbers.reduce((sum, num) => sum + num, 0) / positionNumbers.length;
                    const stdDev = calculateStandardDeviation(positionNumbers);
                    const max = Math.max(...positionNumbers);
                    const min = Math.min(...positionNumbers);
                    
                    // 计算号码分布频率
                    const numberCounts = {};
                    positionNumbers.forEach(num => {
                        numberCounts[num] = (numberCounts[num] || 0) + 1;
                    });
                    
                    stats[position] = {
                        average: avg,
                        standardDeviation: stdDev,
                        min: min,
                        max: max,
                        totalOccurrences: positionNumbers.length,
                        numberFrequencies: numberCounts
                    };
                }
            }
            
            return stats;
        }
        
        // 增强的单个位置预测函数
        function enhancedPredictNextNumberForPosition(positionHistory, position, globalStats, recentPeriods) {
            // 1. 多层次移动平均线分析（短期、中期、长期）
            const shortMA = calculateMovingAverage(positionHistory, 3);
            const mediumMA = calculateMovingAverage(positionHistory, 7);
            const longMA = calculateMovingAverage(positionHistory, Math.min(15, positionHistory.length));
            
            // 2. 增强的趋势分析
            const shortTrend = analyzeTrend(positionHistory, 3);
            const mediumTrend = analyzeTrend(positionHistory, 7);
            const longTrend = analyzeTrend(positionHistory, Math.min(15, positionHistory.length));
            
            // 3. 波动性分析
            const stdDev = calculateStandardDeviation(positionHistory);
            const valueRange = Math.max(...positionHistory) - Math.min(...positionHistory);
            const volatility = valueRange > 0 ? stdDev / valueRange : 0;
            
            // 4. 位置特有模式分析
            const positionStats = globalStats[position];
            
            // 5. 基于多种因素的加权预测
            let predicted = 0;
            
            // 移动平均线权重（近期更重要）
            predicted += shortMA * 0.5;
            predicted += mediumMA * 0.3;
            predicted += longMA * 0.2;
            
            // 根据趋势调整预测值
            const trendStrength = calculateTrendStrength(shortTrend, mediumTrend, longTrend);
            if (trendStrength !== 0) {
                predicted += stdDev * 0.4 * trendStrength;
            }
            
            // 考虑位置特有属性
            if (positionStats) {
                // 位置平均值回归
                predicted = predicted * 0.7 + positionStats.average * 0.3;
                
                // 确保预测值在该位置的合理范围内
                if (predicted < positionStats.min) predicted = positionStats.min + Math.random() * 5;
                if (predicted > positionStats.max) predicted = positionStats.max - Math.random() * 5;
            }
            
            // 6. 添加随机波动（根据波动性调整）
            const randomFactor = (Math.random() - 0.5) * stdDev * Math.min(volatility * 2, 1);
            predicted += randomFactor;
            
            // 7. 四舍五入并确保在1-80范围内
            predicted = Math.round(predicted);
            predicted = Math.max(1, Math.min(80, predicted));
            
            return predicted;
        }
        
        // 计算趋势强度
        function calculateTrendStrength(shortTrend, mediumTrend, longTrend) {
            let strength = 0;
            
            // 将趋势转换为数值
            const trendValues = {
                'up': 1,
                'down': -1,
                'stable': 0
            };
            
            // 短期趋势权重最高
            strength += trendValues[shortTrend] * 0.5;
            strength += trendValues[mediumTrend] * 0.3;
            strength += trendValues[longTrend] * 0.2;
            
            return strength;
        }
        
        // 计算预测置信度分数
        function calculateConfidenceScore(positionHistory, position, globalStats) {
            let score = 0;
            
            // 数据量分数
            const dataVolumeScore = Math.min(positionHistory.length / 20, 1) * 0.3;
            score += dataVolumeScore;
            
            // 趋势一致性分数
            const shortTrend = analyzeTrend(positionHistory, 3);
            const mediumTrend = analyzeTrend(positionHistory, 7);
            const trendConsistency = shortTrend === mediumTrend && shortTrend !== 'stable' ? 0.3 : 0;
            score += trendConsistency;
            
            // 波动性分数（波动性越低，预测越可靠）
            const valueRange = Math.max(...positionHistory) - Math.min(...positionHistory);
            const stdDev = calculateStandardDeviation(positionHistory);
            const volatilityScore = valueRange > 0 ? 0.2 * (1 - Math.min(stdDev / valueRange, 1)) : 0.1;
            score += volatilityScore;
            
            // 位置模式分数
            if (globalStats[position]) {
                const posStats = globalStats[position];
                const recentAvg = positionHistory.slice(0, 5).reduce((sum, num) => sum + num, 0) / 5;
                const avgDiff = Math.abs(recentAvg - posStats.average) / posStats.average;
                const patternScore = 0.2 * (1 - Math.min(avgDiff, 1));
                score += patternScore;
            }
            
            return Math.min(score, 1);
        }
        
        // 为单个位置预测下一个可能出现的号码
        function predictNextNumberForPosition(positionHistory) {
            // 1. 计算移动平均线
            const movingAverage = calculateMovingAverage(positionHistory, 3);
            
            // 2. 分析趋势（上升/下降/平稳）
            const trend = analyzeTrend(positionHistory, 5);
            
            // 3. 计算标准差（波动性）
            const stdDev = calculateStandardDeviation(positionHistory);
            
            // 4. 基于趋势和波动性进行预测
            let predicted = movingAverage;
            
            // 根据趋势调整预测值
            if (trend === 'up') {
                // 上升趋势，预测值略高于移动平均
                predicted += stdDev * 0.3;
            } else if (trend === 'down') {
                // 下降趋势，预测值略低于移动平均
                predicted -= stdDev * 0.3;
            }
            
            // 添加一些随机波动
            predicted += (Math.random() - 0.5) * stdDev * 0.5;
            
            // 四舍五入并确保在1-80范围内
            predicted = Math.round(predicted);
            predicted = Math.max(1, Math.min(80, predicted));
            
            return predicted;
        }
        
        // 计算移动平均线
        function calculateMovingAverage(data, window) {
            if (data.length < window) {
                // 数据不足时，返回平均值
                return data.reduce((sum, num) => sum + num, 0) / data.length;
            }
            
            // 计算最近window个数据的平均值
            const recentData = data.slice(0, window);
            return recentData.reduce((sum, num) => sum + num, 0) / window;
        }
        
        // 分析趋势
        function analyzeTrend(data, window) {
            if (data.length < window) return 'stable';
            
            // 计算最近window期的变化趋势
            let sumChanges = 0;
            for (let i = 1; i < window; i++) {
                sumChanges += data[i - 1] - data[i]; // 注意顺序：最近到较早
            }
            
            const avgChange = sumChanges / (window - 1);
            const stdDev = calculateStandardDeviation(data.slice(0, window));
            
            // 判断趋势：变化超过标准差的20%才认为有明显趋势
            if (Math.abs(avgChange) < stdDev * 0.2) {
                return 'stable';
            } else if (avgChange > 0) {
                return 'up';
            } else {
                return 'down';
            }
        }
        
        // 计算标准差
        function calculateStandardDeviation(data) {
            const mean = data.reduce((sum, num) => sum + num, 0) / data.length;
            const squaredDiffs = data.map(num => Math.pow(num - mean, 2));
            const variance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / data.length;
            return Math.sqrt(variance);
        }
        
        // 历史相似性频率预测算法（保留但不再使用）
        function similarityFrequencyPrediction() {
            console.log('执行高级历史相似性频率预测算法 v3.0...');
            
            // 创建候选分数字典
            const candidateScores = {};
            
            // 先自动更新所有预测对比结果，确保历史数据准确
            updateAllPredictionComparisons();
            
            // 初始化所有号码分数为0
            for (let i = 1; i <= 80; i++) {
                candidateScores[i] = 0;
            }
            
            // 1. 高级频率分析（占35%权重）
            const frequencyWeight = 0.35;
            calculateAdvancedFrequencyScore(candidateScores, frequencyWeight);
            
            // 2. 改进的历史相似性分析（占30%权重）
            const similarityWeight = 0.30;
            calculateEnhancedSimilarityScore(candidateScores, similarityWeight);
            
            // 3. 模式识别分析（占15%权重）
            const patternWeight = 0.15;
            calculatePatternRecognitionScore(candidateScores, patternWeight);
            
            // 4. 高级遗漏分析（占10%权重）
            const missingWeight = 0.10;
            calculateAdvancedMissingScore(candidateScores, missingWeight);
            
            // 5. 统计相关性分析（占5%权重）
            const correlationWeight = 0.05;
            calculateStatisticalCorrelationScore(candidateScores, correlationWeight);
            
            // 6. 自适应调整（占5%权重）
            const adaptiveWeight = 0.05;
            applyAdaptiveAdjustment(candidateScores, adaptiveWeight);
            
            // 转换为数组并排序
            const sortedCandidates = Object.entries(candidateScores)
                .map(([number, score]) => ({ number: parseInt(number), score }))
                .sort((a, b) => b.score - a.score);
            
            // 智能选择策略 - 使用优化的分区平衡算法
            const predicted = selectNumbersWithIntelligentBalance(sortedCandidates);
            
            console.log('高级历史相似性频率预测完成，选中号码:', predicted);
            return predicted;
        }
        
        // 高级频率分析
        function calculateAdvancedFrequencyScore(candidateScores, weight) {
            if (localState.frequencyData && localState.frequencyData.length > 0) {
                const maxFrequency = localState.frequencyData[0].frequency;
                const totalPeriods = localState.kl8HistoryData ? localState.kl8HistoryData.length : 1;
                
                // 计算理想频率
                const idealFrequency = totalPeriods * 20 / 80; // 理论上每个号码应该出现的次数
                
                localState.frequencyData.forEach((item, index) => {
                    // 基础频率得分
                    const frequencyScore = item.frequency / maxFrequency;
                    
                    // 频率偏差得分 - 考虑号码出现频率与理想频率的接近程度
                    const frequencyDeviation = Math.abs(item.frequency - idealFrequency) / idealFrequency;
                    const deviationScore = Math.max(0, 1 - frequencyDeviation * 0.5);
                    
                    // 排名得分 - 频率排名越靠前得分越高
                    const rankScore = 1 - (index / 80);
                    
                    // 综合频率得分
                    const combinedScore = (frequencyScore * 0.5 + deviationScore * 0.3 + rankScore * 0.2) * 100;
                    
                    candidateScores[item.number] += combinedScore * weight;
                });
            }
        }
        
        // 改进的历史相似性分析
        function calculateEnhancedSimilarityScore(candidateScores, weight) {
            if (localState.kl8HistoryData && localState.kl8HistoryData.length >= 15) {
                const recentData = localState.kl8HistoryData.slice(0, 15);
                const numberAppearanceMatrix = {};
                
                // 初始化号码出现矩阵
                for (let i = 1; i <= 80; i++) {
                    numberAppearanceMatrix[i] = new Array(recentData.length).fill(0);
                }
                
                // 构建出现矩阵
                recentData.forEach((period, periodIndex) => {
                    period.numbers.forEach(numberStr => {
                        const number = parseInt(numberStr);
                        numberAppearanceMatrix[number][periodIndex] = 1;
                    });
                });
                
                // 计算号码间的协同出现概率
                for (let currentNum = 1; currentNum <= 80; currentNum++) {
                    let similarityScore = 0;
                    let relevantPeriods = 0;
                    
                    // 找出包含当前号码的所有期数
                    for (let periodIndex = 0; periodIndex < recentData.length; periodIndex++) {
                        if (numberAppearanceMatrix[currentNum][periodIndex] === 1) {
                            relevantPeriods++;
                            
                            // 检查当前期的其他号码
                            recentData[periodIndex].numbers.forEach(coNumberStr => {
                                const coNumber = parseInt(coNumberStr);
                                if (coNumber !== currentNum && candidateScores[coNumber] > 0) {
                                    // 增加相似性分数，考虑期数权重
                                    const periodWeight = (recentData.length - periodIndex) / recentData.length;
                                    similarityScore += periodWeight * candidateScores[coNumber] * 0.01;
                                }
                            });
                        }
                    }
                    
                    // 归一化相似性分数
                    if (relevantPeriods > 0) {
                        candidateScores[currentNum] += (similarityScore / relevantPeriods) * weight;
                    }
                }
                
                // 应用马尔可夫链分析 - 分析号码出现的转移概率
                applyMarkovChainAnalysis(candidateScores, recentData, weight * 0.3);
            }
        }
        
        // 马尔可夫链分析
        function applyMarkovChainAnalysis(candidateScores, recentData, weight) {
            const transitionMatrix = {};
            
            // 初始化转移矩阵
            for (let i = 1; i <= 80; i++) {
                transitionMatrix[i] = {};
                for (let j = 1; j <= 80; j++) {
                    transitionMatrix[i][j] = 0;
                }
            }
            
            // 构建转移矩阵
            for (let periodIndex = 1; periodIndex < recentData.length; periodIndex++) {
                const currentPeriod = recentData[periodIndex - 1]; // 当前期
                const nextPeriod = recentData[periodIndex];      // 下一期
                
                // 计算转移概率
                currentPeriod.numbers.forEach(currentNumStr => {
                    const currentNum = parseInt(currentNumStr);
                    nextPeriod.numbers.forEach(nextNumStr => {
                        const nextNum = parseInt(nextNumStr);
                        transitionMatrix[currentNum][nextNum]++;
                    });
                });
            }
            
            // 计算最后一期的转移概率影响
            if (recentData.length > 0) {
                const lastPeriod = recentData[0];
                const totalTransitions = {};
                
                // 计算每个号码的总转移次数
                for (let i = 1; i <= 80; i++) {
                    totalTransitions[i] = Object.values(transitionMatrix[i]).reduce((sum, count) => sum + count, 0);
                }
                
                // 应用转移概率
                lastPeriod.numbers.forEach(numStr => {
                    const num = parseInt(numStr);
                    if (totalTransitions[num] > 0) {
                        for (let targetNum = 1; targetNum <= 80; targetNum++) {
                            const transitionProbability = transitionMatrix[num][targetNum] / totalTransitions[num];
                            candidateScores[targetNum] += transitionProbability * 100 * weight;
                        }
                    }
                });
            }
        }
        
        // 模式识别分析
        function calculatePatternRecognitionScore(candidateScores, weight) {
            if (localState.kl8HistoryData && localState.kl8HistoryData.length >= 20) {
                // 1. 周期性模式分析
                analyzeCyclicalPatterns(candidateScores, weight * 0.3);
                
                // 2. 热冷号码模式分析
                analyzeHotColdPatterns(candidateScores, weight * 0.4);
                
                // 3. 连号模式分析
                analyzeConsecutivePatterns(candidateScores, weight * 0.3);
            }
        }
        
        // 周期性模式分析
        function analyzeCyclicalPatterns(candidateScores, weight) {
            const cycleLengths = [3, 5, 7, 10]; // 分析不同周期长度
            
            cycleLengths.forEach(cycleLength => {
                for (let number = 1; number <= 80; number++) {
                    const numberStr = number.toString().padStart(2, '0');
                    let cycleMatches = 0;
                    let totalCycles = 0;
                    
                    // 分析周期出现情况
                    for (let i = 0; i < localState.kl8HistoryData.length - cycleLength; i += cycleLength) {
                        totalCycles++;
                        // 检查在周期位置上是否出现
                        if (localState.kl8HistoryData[i].numbers.includes(numberStr)) {
                            // 检查下一个周期位置
                            if (i + cycleLength < localState.kl8HistoryData.length && 
                                localState.kl8HistoryData[i + cycleLength].numbers.includes(numberStr)) {
                                cycleMatches++;
                            }
                        }
                    }
                    
                    // 应用周期匹配得分
                    if (totalCycles > 0) {
                        const cycleScore = (cycleMatches / totalCycles) * 50;
                        candidateScores[number] += cycleScore * weight;
                    }
                }
            });
        }
        
        // 热冷号码模式分析
        function analyzeHotColdPatterns(candidateScores, weight) {
            const hotThreshold = 0.7; // 热门号码阈值
            const coldThreshold = 0.3; // 冷门号码阈值
            
            // 分析最近10期的热冷状态
            for (let number = 1; number <= 80; number++) {
                const numberStr = number.toString().padStart(2, '0');
                let recentAppearances = 0;
                const recentPeriods = Math.min(10, localState.kl8HistoryData.length);
                
                // 统计最近出现次数
                for (let i = 0; i < recentPeriods; i++) {
                    if (localState.kl8HistoryData[i].numbers.includes(numberStr)) {
                        recentAppearances++;
                    }
                }
                
                const appearanceRate = recentAppearances / recentPeriods;
                let patternScore = 0;
                
                // 热门号码模式
                if (appearanceRate > hotThreshold) {
                    // 热门号码倾向于继续热门或即将变冷
                    // 分析热门持续时间
                    let hotStreak = 0;
                    for (let i = 0; i < localState.kl8HistoryData.length; i++) {
                        if (localState.kl8HistoryData[i].numbers.includes(numberStr)) {
                            hotStreak++;
                        } else {
                            break;
                        }
                    }
                    
                    // 热门持续3-5期后，继续热门的概率降低
                    if (hotStreak >= 3 && hotStreak <= 5) {
                        patternScore = 20;
                    } else if (hotStreak > 5) {
                        patternScore = 10; // 过热，概率降低
                    } else {
                        patternScore = 30; // 刚开始热，概率较高
                    }
                }
                // 冷门号码模式
                else if (appearanceRate < coldThreshold) {
                    // 冷门号码即将反弹的概率分析
                    let coldStreak = 0;
                    for (let i = 0; i < localState.kl8HistoryData.length; i++) {
                        if (!localState.kl8HistoryData[i].numbers.includes(numberStr)) {
                            coldStreak++;
                        } else {
                            break;
                        }
                    }
                    
                    // 冷号时间越长，反弹概率越高
                    patternScore = Math.min(40, coldStreak * 2);
                }
                
                candidateScores[number] += patternScore * weight;
            }
        }
        
        // 连号模式分析
        function analyzeConsecutivePatterns(candidateScores, weight) {
            // 统计连号出现的频率
            const consecutiveCounts = {};
            for (let i = 1; i <= 79; i++) {
                consecutiveCounts[i] = 0;
            }
            
            // 分析历史数据中的连号模式
            localState.kl8HistoryData.forEach(period => {
                const sortedNumbers = period.numbers.map(n => parseInt(n)).sort((a, b) => a - b);
                
                for (let i = 0; i < sortedNumbers.length - 1; i++) {
                    if (sortedNumbers[i + 1] - sortedNumbers[i] === 1) {
                        consecutiveCounts[sortedNumbers[i]]++;
                    }
                }
            });
            
            // 应用连号模式得分
            for (let baseNum = 1; baseNum <= 79; baseNum++) {
                const consecutiveScore = consecutiveCounts[baseNum] * 2;
                
                // 为基础号码和连续号码增加分数
                candidateScores[baseNum] += consecutiveScore * weight;
                candidateScores[baseNum + 1] += consecutiveScore * weight;
            }
        }
        
        // 高级遗漏分析
        function calculateAdvancedMissingScore(candidateScores, weight) {
            for (let number = 1; number <= 80; number++) {
                const numberStr = number.toString().padStart(2, '0');
                
                // 计算当前遗漏期数
                let currentMissing = 0;
                let lastAppearance = -1;
                
                for (let i = 0; i < localState.kl8HistoryData.length; i++) {
                    if (localState.kl8HistoryData[i].numbers.includes(numberStr)) {
                        lastAppearance = i;
                        break;
                    }
                    currentMissing++;
                }
                
                // 计算历史平均遗漏期数和标准差
                let missingPeriods = [];
                let tempMissing = 0;
                
                for (let i = 0; i < localState.kl8HistoryData.length; i++) {
                    if (localState.kl8HistoryData[i].numbers.includes(numberStr)) {
                        if (tempMissing > 0) {
                            missingPeriods.push(tempMissing);
                        }
                        tempMissing = 0;
                    } else {
                        tempMissing++;
                    }
                }
                
                // 计算遗漏得分
                let missingScore = 20; // 基础分
                
                if (missingPeriods.length > 0) {
                    const avgMissing = missingPeriods.reduce((sum, val) => sum + val, 0) / missingPeriods.length;
                    const stdMissing = Math.sqrt(
                        missingPeriods.reduce((sum, val) => sum + Math.pow(val - avgMissing, 2), 0) / missingPeriods.length
                    );
                    
                    // 当前遗漏与平均遗漏的关系
                    const missingRatio = currentMissing / avgMissing;
                    
                    // 使用正态分布思想：当遗漏达到平均值+标准差时，概率显著增加
                    if (missingRatio > 1.5) {
                        missingScore = 60;
                    } else if (missingRatio > 1.2) {
                        missingScore = 40;
                    } else if (missingRatio < 0.5) {
                        missingScore = 10; // 遗漏较少，概率较低
                    }
                } else if (currentMissing > 20) {
                    // 从未出现或长期未出现
                    missingScore = 50;
                }
                
                candidateScores[number] += missingScore * weight;
            }
        }
        
        // 统计相关性分析
        function calculateStatisticalCorrelationScore(candidateScores, weight) {
            if (localState.kl8HistoryData && localState.kl8HistoryData.length >= 15) {
                // 分析号码之间的统计相关性
                const correlationMatrix = calculateCorrelationMatrix();
                
                // 找出当前得分较高的号码
                const topNumbers = Object.entries(candidateScores)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 10)
                    .map(([num]) => parseInt(num));
                
                // 为与高分号码高度相关的其他号码增加分数
                for (const topNum of topNumbers) {
                    for (let relatedNum = 1; relatedNum <= 80; relatedNum++) {
                        if (topNum !== relatedNum && correlationMatrix[topNum] && correlationMatrix[topNum][relatedNum]) {
                            const correlationScore = correlationMatrix[topNum][relatedNum] * 30;
                            candidateScores[relatedNum] += correlationScore * weight;
                        }
                    }
                }
            }
        }
        
        // 计算相关性矩阵
        function calculateCorrelationMatrix() {
            const correlationMatrix = {};
            const totalPeriods = localState.kl8HistoryData.length;
            
            // 初始化矩阵
            for (let i = 1; i <= 80; i++) {
                correlationMatrix[i] = {};
            }
            
            // 计算共现次数
            for (let i = 1; i <= 80; i++) {
                for (let j = i + 1; j <= 80; j++) {
                    let coOccurrences = 0;
                    const numIStr = i.toString().padStart(2, '0');
                    const numJStr = j.toString().padStart(2, '0');
                    
                    for (const period of localState.kl8HistoryData) {
                        if (period.numbers.includes(numIStr) && period.numbers.includes(numJStr)) {
                            coOccurrences++;
                        }
                    }
                    
                    // 计算相关系数
                    const iFrequency = localState.frequencyData.find(item => item.number === i)?.frequency || 0;
                    const jFrequency = localState.frequencyData.find(item => item.number === j)?.frequency || 0;
                    
                    // 使用修正的相关系数计算
                    const expectedCoOccurrences = (iFrequency * jFrequency) / totalPeriods;
                    let correlation = 0;
                    
                    if (expectedCoOccurrences > 0) {
                        correlation = Math.min(1, coOccurrences / expectedCoOccurrences);
                    }
                    
                    correlationMatrix[i][j] = correlation;
                    correlationMatrix[j][i] = correlation; // 对称矩阵
                }
            }
            
            return correlationMatrix;
        }
        
        // 自适应调整
        function applyAdaptiveAdjustment(candidateScores, weight) {
            // 基于历史预测准确率进行自适应调整
            if (localState.predictionHistory && localState.predictionHistory.length > 0) {
                const recentPredictions = localState.predictionHistory.slice(0, 10);
                const numberSuccessRate = {};
                
                // 初始化成功率
                for (let i = 1; i <= 80; i++) {
                    numberSuccessRate[i] = { hits: 0, total: 0 };
                }
                
                // 统计每个号码的预测成功率
                recentPredictions.forEach(prediction => {
                    if (prediction.accuracy !== '--') {
                        const predictedNumbers = prediction.numbers;
                        
                        // 找到对应的开奖结果
                        const correspondingResult = localState.kl8HistoryData.find(
                            result => result.period === prediction.period
                        );
                        
                        if (correspondingResult) {
                            const resultNumbers = correspondingResult.numbers.map(n => parseInt(n));
                            
                            predictedNumbers.forEach(num => {
                                numberSuccessRate[num].total++;
                                if (resultNumbers.includes(num)) {
                                    numberSuccessRate[num].hits++;
                                }
                            });
                        }
                    }
                });
                
                // 应用自适应调整
                for (let number = 1; number <= 80; number++) {
                    const stats = numberSuccessRate[number];
                    if (stats.total > 0) {
                        const successRate = stats.hits / stats.total;
                        // 成功预测的号码给予额外奖励，预测错误的给予惩罚
                        const adjustment = (successRate - 0.25) * 40; // 0.25是随机概率基准
                        candidateScores[number] += adjustment * weight;
                    }
                }
            }
        }
        
        // 智能选择策略 - 优化的分区平衡算法
        function selectNumbersWithIntelligentBalance(sortedCandidates) {
            const predicted = [];
            const numbersToPick = 20;
            const zoneCounts = [0, 0, 0, 0]; // 四个分区的计数器
            
            // 1. 首先获取最优分区分布
            const optimalDistribution = calculateOptimalZoneDistribution();
            
            // 2. 按分数排序选择，但确保分区平衡
            let round = 0;
            const maxRounds = 5;
            
            while (predicted.length < numbersToPick && round < maxRounds) {
                for (let i = 0; i < sortedCandidates.length && predicted.length < numbersToPick; i++) {
                    const num = sortedCandidates[i].number;
                    const zoneIndex = getZoneIndex(num);
                    
                    // 确定当前分区允许的最大选择数量
                    const maxForZone = optimalDistribution[zoneIndex] + 2; // 允许一定的灵活性
                    const minForZone = Math.max(0, optimalDistribution[zoneIndex] - 2); // 最低保证数量
                    
                    // 策略：
                    // 1. 如果分区数量少于最小值，优先选择
                    // 2. 如果分区数量未超过最大值，并且分数足够高，选择
                    // 3. 最后一轮，放开限制，确保选够20个
                    const highScoreThreshold = sortedCandidates[Math.floor(sortedCandidates.length * 0.3)].score;
                    const isHighScore = sortedCandidates[i].score >= highScoreThreshold * 0.8;
                    
                    if (!predicted.includes(num)) {
                        if (zoneCounts[zoneIndex] < minForZone ||
                            (zoneCounts[zoneIndex] < maxForZone && isHighScore) ||
                            round === maxRounds - 1) {
                            
                            predicted.push(num);
                            zoneCounts[zoneIndex]++;
                        }
                    }
                }
                round++;
            }
            
            // 3. 如果还是没选够，补充最高分的号码
            if (predicted.length < numbersToPick) {
                for (let i = 0; i < sortedCandidates.length && predicted.length < numbersToPick; i++) {
                    const num = sortedCandidates[i].number;
                    if (!predicted.includes(num)) {
                        predicted.push(num);
                    }
                }
            }
            
            return predicted;
        }
        
        // 获取号码所在分区索引
        function getZoneIndex(number) {
            if (number <= 20) return 0;
            else if (number <= 40) return 1;
            else if (number <= 60) return 2;
            else return 3;
        }
        
        // 计算最优分区分布
        function calculateOptimalZoneDistribution() {
            // 默认的基础分布（每个分区5个号码）
            const baseDistribution = [5, 5, 5, 5];
            
            if (!localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
                return baseDistribution;
            }
            
            // 分析最近10期的分区分布情况
            const recentPeriods = Math.min(10, localState.kl8HistoryData.length);
            const zoneDistributionHistory = [];
            
            // 收集历史分区分布数据
            for (let i = 0; i < recentPeriods; i++) {
                const zoneCounts = [0, 0, 0, 0];
                localState.kl8HistoryData[i].numbers.forEach(numStr => {
                    const num = parseInt(numStr);
                    const zoneIndex = getZoneIndex(num);
                    zoneCounts[zoneIndex]++;
                });
                zoneDistributionHistory.push(zoneCounts);
            }
            
            // 计算每个分区的平均出现次数
            const avgZoneCounts = [0, 0, 0, 0];
            zoneDistributionHistory.forEach(counts => {
                for (let i = 0; i < 4; i++) {
                    avgZoneCounts[i] += counts[i];
                }
            });
            
            // 归一化平均分布
            const totalNumbersPerPeriod = 20;
            let optimalDistribution = [];
            let remaining = totalNumbersPerPeriod;
            
            // 首先分配整数部分
            for (let i = 0; i < 4; i++) {
                avgZoneCounts[i] = avgZoneCounts[i] / recentPeriods;
                const rounded = Math.floor(avgZoneCounts[i]);
                optimalDistribution.push(rounded);
                remaining -= rounded;
            }
            
            // 分配剩余的号码，优先考虑最接近下一个整数的分区
            const fractionalParts = avgZoneCounts.map((avg, i) => ({
                index: i,
                fractional: avg - optimalDistribution[i]
            })).sort((a, b) => b.fractional - a.fractional);
            
            for (let i = 0; i < remaining; i++) {
                optimalDistribution[fractionalParts[i].index]++;
            }
            
            // 添加一些随机性和灵活性，避免过度拟合
            for (let i = 0; i < 4; i++) {
                // 根据历史数据的波动程度调整灵活性
                const zoneVariance = calculateZoneVariance(zoneDistributionHistory, i);
                const flexibility = Math.min(2, Math.max(0, Math.round(zoneVariance * 0.5)));
                
                // 确保分布不会偏离基础太多
                optimalDistribution[i] = Math.min(8, Math.max(3, optimalDistribution[i]));
            }
            
            return optimalDistribution;
        }
        
        // 计算分区分布的方差
        function calculateZoneVariance(zoneDistributionHistory, zoneIndex) {
            const values = zoneDistributionHistory.map(counts => counts[zoneIndex]);
            const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
            const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
            return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
        }
        // 智能预测算法 - 优化版（v3.0）
        // 智能预测算法 - 增强版
        function smartPrediction() {
                // 创建候选分数字典
                const candidateScores = {};
                
                // 先自动更新所有预测对比结果，确保历史数据准确
                updateAllPredictionComparisons();
                
                // 1. 频率因素（占35%权重）
                const frequencyWeight = 0.35;
            for (let i = 0; i < localState.frequencyData.length; i++) {
                const item = localState.frequencyData[i];
                // 出现次数越多，分数越高
                const score = (80 - i) * frequencyWeight;
                candidateScores[item.number] = score;
            }
            
            // 2. 平衡因素（占25%权重）
            const balancedWeight = 0.25;
            const zoneCounts = {1: 0, 2: 0, 3: 0, 4: 0};

            // 3. 近期趋势分析（新增：分析最近5期号码分布）
            const trendWeight = 0.2;
            const recentTrend = {};
            const recentPeriods = 5;
            
            // 初始化趋势分析
            for (let i = 1; i <= 80; i++) {
                const number = i.toString().padStart(2, '0');
                recentTrend[number] = 0;
            }
            
            // 分析最近几期号码出现情况
            if (localState.kl8HistoryData && localState.kl8HistoryData.length >= recentPeriods) {
                const recentData = localState.kl8HistoryData.slice(0, recentPeriods);
                
                recentData.forEach((periodData, periodIndex) => {
                    // 近期数据权重递减
                    const periodWeight = (recentPeriods - periodIndex) / recentPeriods;
                    
                    periodData.numbers.forEach(number => {
                        recentTrend[number] += periodWeight;
                    });
                });
            }
            
            // 应用趋势权重
            for (let num in candidateScores) {
                candidateScores[num] += recentTrend[num.toString().padStart(2, '0')] * trendWeight;
            }

            // 4. 遗漏分析（新增：分析长时间未出现的号码）
            const missingWeight = 0.1;
            
            // 计算每个号码的遗漏值（基于其在频率列表中的位置）
            for (let i = 0; i < localState.frequencyData.length; i++) {
                const item = localState.frequencyData[i];
                // 遗漏值：位置越靠后，遗漏值越高
                const missingScore = i * 0.05 * missingWeight;
                candidateScores[item.number] += missingScore;
            }

            // 5. 随机因素（占5%权重）
            for (let num in candidateScores) {
                // 为每个号码添加一些随机因素，模拟实际彩票的随机性
                const randomFactor = Math.random() * 5;
                candidateScores[num] += randomFactor;
            }
            
            // 转换为数组并排序
            const sortedCandidates = Object.entries(candidateScores)
                .map(([number, score]) => ({ number: parseInt(number), score }))
                .sort((a, b) => b.score - a.score);
            
            // 选择前20个号码
            const predicted = [];
            const numbersToPick = 20;
            
            // 确保每个分区至少有3个号码
            while (predicted.length < numbersToPick) {
                for (let i = 0; i < sortedCandidates.length && predicted.length < numbersToPick; i++) {
                    const num = sortedCandidates[i].number;
                    
                    // 确定号码所在分区
                    let zone = 1;
                    if (num <= 20) zone = 1;
                    else if (num <= 40) zone = 2;
                    else if (num <= 60) zone = 3;
                    else zone = 4;
                    
                    // 如果分区数量不足且号码未被选择，则添加
                    if (zoneCounts[zone] < 8 && !predicted.includes(num)) {
                        predicted.push(num);
                        zoneCounts[zone]++;
                    }
                }
            }
            
            // 如果还是没选够，直接从最高分选择
            if (predicted.length < numbersToPick) {
                for (let i = 0; i < sortedCandidates.length && predicted.length < numbersToPick; i++) {
                    const num = sortedCandidates[i].number;
                    if (!predicted.includes(num)) {
                        predicted.push(num);
                    }
                }
            }
            
            return predicted;
        }

        // 平衡分区预测 - 增强版
        // 平衡分区预测算法 v3.0 (优化版)
        function balancedPrediction() {
            // 1. 计算历史分区分布统计，确定最优分区比例
            const optimalZoneDistribution = calculateOptimalZoneDistribution();
            
            // 2. 为每个分区创建评分表
            const zoneScores = createZoneScoreTables();
            
            // 3. 从每个分区选择评分最高的号码
            const predicted = [];
            
            // 按照最优分区分布选择号码
            for (let zoneIndex = 0; zoneIndex < 4; zoneIndex++) {
                const numbersToSelect = optimalZoneDistribution[zoneIndex];
                const sortedNumbers = zoneScores[zoneIndex].sort((a, b) => b.totalScore - a.totalScore);
                
                // 选择前N个最高分的号码
                for (let i = 0; i < numbersToSelect && i < sortedNumbers.length; i++) {
                    predicted.push(sortedNumbers[i].number);
                }
            }
            
            return predicted;
        }
        
        // 计算历史最优分区分布
        function calculateOptimalZoneDistribution() {
            // 默认均匀分布
            let optimalDistribution = [5, 5, 5, 5];
            
            // 如果有历史数据，分析最佳分区分布
            if (localState.kl8HistoryData && localState.kl8HistoryData.length > 0) {
                const zoneDistributionCounts = [
                    Array(11).fill(0), // 分区1: 0-10个号码
                    Array(11).fill(0), // 分区2: 0-10个号码
                    Array(11).fill(0), // 分区3: 0-10个号码
                    Array(11).fill(0)  // 分区4: 0-10个号码
                ];
                
                // 统计历史开奖号码的分区分布
                for (const periodData of localState.kl8HistoryData) {
                    const zone1 = periodData.numbers.filter(num => parseInt(num) <= 20).length;
                    const zone2 = periodData.numbers.filter(num => parseInt(num) > 20 && parseInt(num) <= 40).length;
                    const zone3 = periodData.numbers.filter(num => parseInt(num) > 40 && parseInt(num) <= 60).length;
                    const zone4 = periodData.numbers.filter(num => parseInt(num) > 60).length;
                    
                    zoneDistributionCounts[0][Math.min(zone1, 10)]++;
                    zoneDistributionCounts[1][Math.min(zone2, 10)]++;
                    zoneDistributionCounts[2][Math.min(zone3, 10)]++;
                    zoneDistributionCounts[3][Math.min(zone4, 10)]++;
                }
                
                // 找到每个分区出现频率最高的数量
                for (let zoneIndex = 0; zoneIndex < 4; zoneIndex++) {
                    const maxCount = Math.max(...zoneDistributionCounts[zoneIndex]);
                    const optimalCount = zoneDistributionCounts[zoneIndex].indexOf(maxCount);
                    // 限制在合理范围内，并且总和为20
                    optimalDistribution[zoneIndex] = Math.max(3, Math.min(8, optimalCount));
                }
                
                // 确保总和为20，进行微调
                let total = optimalDistribution.reduce((sum, count) => sum + count, 0);
                while (total !== 20) {
                    if (total < 20) {
                        // 找出历史出现频率第二高的分区增加
                        const variances = optimalDistribution.map((count, zoneIndex) => {
                            const secondMaxCount = [...zoneDistributionCounts[zoneIndex]].sort((a, b) => b - a)[1] || 0;
                            return secondMaxCount;
                        });
                        const zoneToIncrease = variances.indexOf(Math.max(...variances));
                        optimalDistribution[zoneToIncrease]++;
                    } else {
                        // 找出历史出现频率较低的分区减少
                        const zoneToDecrease = optimalDistribution.indexOf(Math.min(...optimalDistribution));
                        optimalDistribution[zoneToDecrease]--;
                    }
                    total = optimalDistribution.reduce((sum, count) => sum + count, 0);
                }
            }
            
            return optimalDistribution;
        }
        
        // 为每个分区创建号码评分表
        function createZoneScoreTables() {
            // 初始化4个分区的评分表
            const zoneScores = [
                [], [], [], [] // 分别对应4个分区
            ];
            
            // 计算每个号码的综合评分
            for (let number = 1; number <= 80; number++) {
                // 确定分区
                let zoneIndex = 0;
                if (number <= 20) zoneIndex = 0;
                else if (number <= 40) zoneIndex = 1;
                else if (number <= 60) zoneIndex = 2;
                else zoneIndex = 3;
                
                // 获取频率数据
                const frequencyData = localState.frequencyData.find(item => item.number === number);
                const frequency = frequencyData ? frequencyData.frequency : 0;
                const maxFrequency = localState.frequencyData.length > 0 ? localState.frequencyData[0].frequency : 1;
                const normalizedFrequency = maxFrequency > 0 ? frequency / maxFrequency : 0;
                
                // 计算分区内频率排名
                const zoneNumbers = [];
                for (let num = zoneIndex * 20 + 1; num <= (zoneIndex + 1) * 20; num++) {
                    const fData = localState.frequencyData.find(item => item.number === num);
                    zoneNumbers.push({ number: num, frequency: fData ? fData.frequency : 0 });
                }
                zoneNumbers.sort((a, b) => b.frequency - a.frequency);
                const zoneFrequencyRank = zoneNumbers.findIndex(item => item.number === number) + 1;
                const normalizedZoneRank = 1 - (zoneFrequencyRank - 1) / 20;
                
                // 计算趋势得分（基于最近10期的表现）
                const recentTrendScore = calculateRecentTrendScore(number);
                
                // 计算遗漏分析得分
                const missingScore = calculateMissingScore(number);
                
                // 计算分区平衡得分（考虑该分区内号码的分布）
                const zoneBalanceScore = calculateZoneBalanceScore(number, zoneIndex, zoneNumbers);
                
                // 综合评分（加权平均）
                const totalScore = (
                    normalizedZoneRank * 0.35 +  // 分区内频率排名权重
                    recentTrendScore * 0.25 +     // 近期趋势权重
                    missingScore * 0.20 +         // 遗漏分析权重
                    zoneBalanceScore * 0.10 +     // 分区平衡权重
                    normalizedFrequency * 0.10    // 整体频率权重
                );
                
                zoneScores[zoneIndex].push({
                    number: number,
                    frequency: frequency,
                    totalScore: totalScore,
                    zoneRank: zoneFrequencyRank
                });
            }
            
            return zoneScores;
        }
        
        // 计算近期趋势得分
        function calculateRecentTrendScore(number) {
            if (!localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
                return 0.5; // 默认中等概率
            }
            
            // 分析最近10期
            const recentPeriods = Math.min(10, localState.kl8HistoryData.length);
            let appearanceCount = 0;
            let consecutiveMisses = 0;
            
            for (let i = 0; i < recentPeriods; i++) {
                const periodData = localState.kl8HistoryData[i];
                const appeared = periodData.numbers.includes(number.toString().padStart(2, '0'));
                
                if (appeared) {
                    appearanceCount++;
                    consecutiveMisses = 0;
                } else {
                    consecutiveMisses++;
                }
            }
            
            // 计算出现频率
            const appearanceRate = appearanceCount / recentPeriods;
            
            // 考虑连空情况的调整
            let adjustment = 0;
            if (consecutiveMisses > 0) {
                // 连空越多，调整值越高（表示越可能出现）
                adjustment = Math.min(0.3, consecutiveMisses * 0.05);
            }
            
            return Math.min(1, appearanceRate + adjustment);
        }
        
        // 计算遗漏分析得分
        function calculateMissingScore(number) {
            if (!localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
                return 0.5;
            }
            
            // 计算遗漏期数
            let missingCount = 0;
            for (const periodData of localState.kl8HistoryData) {
                if (!periodData.numbers.includes(number.toString().padStart(2, '0'))) {
                    missingCount++;
                } else {
                    break;
                }
            }
            
            // 基于遗漏期数计算得分，使用sigmoid函数让得分更平滑
            // 适当的阈值：如果遗漏超过20期，认为概率明显增加
            const normalizedMissing = Math.min(missingCount / 20, 1);
            const score = 0.5 + (1 / (1 + Math.exp(-6 * (normalizedMissing - 0.5))) - 0.5) * 2;
            
            return score;
        }
        
        // 计算分区平衡得分
        function calculateZoneBalanceScore(number, zoneIndex, zoneNumbers) {
            // 计算该号码在分区中的奇偶分布平衡贡献
            const isEven = number % 2 === 0;
            const oddNumbers = zoneNumbers.filter(n => n.number % 2 !== 0).length;
            const evenNumbers = zoneNumbers.filter(n => n.number % 2 === 0).length;
            
            // 如果奇偶分布不均衡，倾向于补充较少的那一类
            let parityBalanceScore = 0.5;
            if (oddNumbers > evenNumbers && !isEven) {
                parityBalanceScore = 0.3; // 奇数太多，降低奇数权重
            } else if (evenNumbers > oddNumbers && isEven) {
                parityBalanceScore = 0.3; // 偶数太多，降低偶数权重
            } else if (oddNumbers < evenNumbers && !isEven) {
                parityBalanceScore = 0.7; // 奇数太少，提高奇数权重
            } else if (evenNumbers < oddNumbers && isEven) {
                parityBalanceScore = 0.7; // 偶数太少，提高偶数权重
            }
            
            // 计算号码大小分布平衡贡献
            const zoneMid = zoneIndex * 20 + 10;
            const distanceFromMid = Math.abs(number - zoneMid);
            const normalizedDistance = distanceFromMid / 10; // 标准化到0-1范围
            const sizeBalanceScore = 1 - normalizedDistance * 0.3; // 距离中心越近得分越高，但给予一定差异
            
            return (parityBalanceScore * 0.6 + sizeBalanceScore * 0.4);
        }
        
        // 新增：AI预测更新函数
        function updateAIPrediction() {
            showNotification('正在更新AI预测模型...', 'info');
            
            // 重新计算频率数据
            if (localState.kl8HistoryData && localState.kl8HistoryData.length > 0) {
                // 计算频率
                const frequencies = {};
                for (let i = 1; i <= 80; i++) {
                    const number = i.toString().padStart(2, '0');
                    frequencies[number] = 0;
                }
                
                // 统计每个号码出现的次数
                for (const periodData of localState.kl8HistoryData) {
                    for (const number of periodData.numbers) {
                        if (frequencies.hasOwnProperty(number)) {
                            frequencies[number]++;
                        }
                    }
                }
                
                // 转换为数组并按频率降序排序
                localState.frequencyData = Object.entries(frequencies)
                    .map(([number, frequency]) => ({ number: parseInt(number), frequency }))
                    .sort((a, b) => b.frequency - a.frequency);
                
                // 更新图表
                updateFrequencyChart();
                
                // 更新模型状态
                document.getElementById('modelStatus').textContent = '已更新';
                document.getElementById('modelStatus').className = 'text-success';
                
                showNotification('AI预测模型已更新', 'success');
            } else {
                showNotification('无数据可用于更新模型', 'warning');
            }
        }
        
        // 数据对比功能将在后面定义

        // 更新预测号码显示
        function updatePredictedNumbersDisplay(numbers, period) {
            const container = document.getElementById('predictedNumbers');
            
            // 清空容器
            container.innerHTML = '';
            
            if (numbers.length === 0) {
                container.innerHTML = '<p class="text-gray-400 italic text-sm">点击AI选号生成推荐</p>';
                return;
            }
            
            // 显示预测期号
            if (period) {
                const periodElement = document.createElement('div');
                periodElement.className = 'w-full text-center text-sm font-medium text-primary mb-2';
                periodElement.textContent = '预测期号：' + period;
                container.appendChild(periodElement);
            }
            
            // 显示预测号码
            numbers.forEach(number => {
                const ball = document.createElement('div');
                ball.className = 'number-ball bg-secondary';
                ball.textContent = number;
                
                // 添加点击事件，快速选择这个号码
                ball.addEventListener('click', function() {
                    // 如果已经选择了20个号码，并且当前点击的号码不在已选列表中，提示用户
                    if (localState.selectedNumbers.size >= 20 && !localState.selectedNumbers.has(number)) {
                        showNotification('最多只能选择20个号码', 'warning');
                        return;
                    }
                    toggleNumberSelection(number);
                });
                
                container.appendChild(ball);
            });
            
            // 更新分区统计
            updateZoneStatistics(numbers);
        }

        // 更新分区统计
        function updateZoneStatistics(numbers) {
            const zone1 = numbers.filter(num => num <= 20).length;
            const zone2 = numbers.filter(num => num > 20 && num <= 40).length;
            const zone3 = numbers.filter(num => num > 40 && num <= 60).length;
            const zone4 = numbers.filter(num => num > 60).length;
            
            document.getElementById('zone1Count').textContent = zone1 + ' (' + (zone1/20*100).toFixed(1) + '%)';
            document.getElementById('zone2Count').textContent = zone2 + ' (' + (zone2/20*100).toFixed(1) + '%)';
            document.getElementById('zone3Count').textContent = zone3 + ' (' + (zone3/20*100).toFixed(1) + '%)';
            document.getElementById('zone4Count').textContent = zone4 + ' (' + (zone4/20*100).toFixed(1) + '%)';
        }

        // 保存预测记录
        function savePrediction() {
            if (localState.selectedNumbers.size !== 20) {
                showNotification('请先选择20个号码', 'warning');
                return;
            }
            
            // 获取预测期号（如果有）
            let predictionPeriod = '';
            if (localState.lastPrediction && localState.lastPrediction.period) {
                predictionPeriod = localState.lastPrediction.period;
            } else {
                // 如果没有预测期号，生成一个
                predictionPeriod = getNextPeriodNumber();
            }
            
            const prediction = {
                id: Date.now(),
                timestamp: new Date().toLocaleString('zh-CN'),
                method: document.getElementById('predictionMethod').value,
                numbers: Array.from(localState.selectedNumbers).sort((a, b) => a - b),
                accuracy: '--',
                correctCount: 0,
                period: predictionPeriod
            };
            
            // 添加到历史记录
            localState.predictionHistory.unshift(prediction);
            
            // 保存到本地存储
            savePredictionHistory();
            
            // 更新UI
            updateHistoryTable();
            
            showNotification('预测记录已保存', 'success');
        }

        // 保存预测历史到本地存储
        function savePredictionHistory() {
            try {
                // 只保留最近100条记录
                const historyToSave = localState.predictionHistory.slice(0, 100);
                localStorage.setItem('kl8PredictionHistory', JSON.stringify(historyToSave));
            } catch (error) {
                console.error('保存预测历史失败:', error);
            }
        }

        // 从本地存储加载预测历史
        function loadPredictionHistory() {
            try {
                const savedHistory = localStorage.getItem('kl8PredictionHistory');
                if (savedHistory) {
                    localState.predictionHistory = JSON.parse(savedHistory);
                    updateHistoryTable();
                }
                // 返回预测历史记录
                return localState.predictionHistory || [];
            } catch (error) {
                console.error('加载预测历史失败:', error);
                localState.predictionHistory = [];
                return [];
            }
        }

        // 更新历史记录表格
        function updateHistoryTable() {
            const tbody = document.getElementById('historyTableBody');
            
            // 清空表格
            tbody.innerHTML = '';
            
            if (localState.predictionHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="px-4 py-8 text-center text-gray-400 italic">暂无预测记录</td></tr>';
                return;
            }
            
            // 显示最近10条记录
            const recentHistory = localState.predictionHistory.slice(0, 10);
            
            recentHistory.forEach(prediction => {
                const row = document.createElement('tr');
                row.className = 'border-b hover:bg-gray-50 transition-colors';
                
                // 预测时间
                const timeCell = document.createElement('td');
                timeCell.className = 'px-4 py-3 text-sm';
                timeCell.textContent = prediction.timestamp;
                row.appendChild(timeCell);
                
                // 预测期号
                const periodCell = document.createElement('td');
                periodCell.className = 'px-4 py-3 text-sm font-medium text-primary';
                periodCell.textContent = prediction.period || '--';
                row.appendChild(periodCell);
                
                // 预测方法
                const methodCell = document.createElement('td');
                methodCell.className = 'px-4 py-3 text-sm';
                
                let methodText = '';
                switch (prediction.method) {
                    case 'smart':
                        methodText = '智能预测';
                        break;
                    case 'balanced':
                        methodText = '平衡分区';
                        break;
                    case 'frequency':
                        methodText = '频率预测';
                        break;
                    default:
                        methodText = '手动选择';
                }
                
                methodCell.textContent = methodText;
                row.appendChild(methodCell);
                
                // 预测号码
                const numbersCell = document.createElement('td');
                numbersCell.className = 'px-4 py-3';
                
                const numbersContainer = document.createElement('div');
                numbersContainer.className = 'flex flex-wrap gap-1';
                
                prediction.numbers.slice(0, 10).forEach(number => {
                    const ball = document.createElement('div');
                    ball.className = 'w-5 h-5 rounded-full bg-primary/10 text-primary text-xs flex items-center justify-center';
                    ball.textContent = number;
                    numbersContainer.appendChild(ball);
                });
                
                if (prediction.numbers.length > 10) {
                    const moreText = document.createElement('span');
                    moreText.className = 'text-xs text-gray-500';
                    moreText.textContent = '...等' + prediction.numbers.length + '个号码';
                    numbersContainer.appendChild(moreText);
                }
                
                numbersCell.appendChild(numbersContainer);
                row.appendChild(numbersCell);
                
                // 准确率
                const accuracyCell = document.createElement('td');
                accuracyCell.className = 'px-4 py-3 text-sm';
                accuracyCell.textContent = prediction.accuracy;
                row.appendChild(accuracyCell);
                
                // 操作
                const actionCell = document.createElement('td');
                actionCell.className = 'px-4 py-3 text-sm';
                
                const viewBtn = document.createElement('button');
                viewBtn.className = 'text-primary hover:text-primary/80 transition-colors';
                viewBtn.innerHTML = '<i class="fa fa-eye"></i> 查看';
                viewBtn.addEventListener('click', function() {
                    viewPredictionDetails(prediction);
                });
                
                actionCell.appendChild(viewBtn);
                row.appendChild(actionCell);
                
                tbody.appendChild(row);
            });
        }

        // 查看预测详情
        function viewPredictionDetails(prediction) {
            // 清空详情容器
            const detailedHistory = document.getElementById('detailedHistory');
            detailedHistory.innerHTML = '';
            
            // 创建详情卡片
            const detailCard = document.createElement('div');
            detailCard.className = 'bg-white border rounded-lg p-4';
            
            // 添加标题
            const title = document.createElement('h3');
            title.className = 'text-lg font-semibold mb-3';
            title.textContent = '预测记录 - ' + prediction.timestamp;
            detailCard.appendChild(title);
            
            // 添加预测期号
            const periodInfo = document.createElement('p');
            periodInfo.className = 'text-sm font-medium text-primary mb-3';
            periodInfo.textContent = '预测期号: ' + (prediction.period || '--');
            detailCard.appendChild(periodInfo);
            
            // 添加预测方法
            const methodInfo = document.createElement('p');
            methodInfo.className = 'text-sm text-gray-700 mb-3';
            
            let methodText = '';
            switch (prediction.method) {
                case 'smart':
                    methodText = '智能预测';
                    break;
                case 'balanced':
                    methodText = '平衡分区';
                    break;
                case 'frequency':
                    methodText = '频率预测';
                    break;
                case 'positionTrend':
                    methodText = '位置走势预测';
                    break;
                default:
                    methodText = '手动选择';
            }

            methodInfo.textContent = '预测方法: ' + methodText;
            detailCard.appendChild(methodInfo);
            
            // 添加预测号码
            const numbersTitle = document.createElement('p');
            numbersTitle.className = 'text-sm font-medium text-gray-700 mb-2';
            numbersTitle.textContent = '预测号码:';
            detailCard.appendChild(numbersTitle);
            
            const numbersContainer = document.createElement('div');
            numbersContainer.className = 'flex flex-wrap gap-2 mb-4';
            
            prediction.numbers.forEach(number => {
                const ball = document.createElement('div');
                ball.className = 'number-ball bg-primary';
                ball.textContent = number;
                numbersContainer.appendChild(ball);
            });
            
            detailCard.appendChild(numbersContainer);
            
            // 添加分区统计
            const statsTitle = document.createElement('p');
            statsTitle.className = 'text-sm font-medium text-gray-700 mb-2';
            statsTitle.textContent = '分区统计:';
            detailCard.appendChild(statsTitle);
            
            const zone1 = prediction.numbers.filter(num => num <= 20).length;
            const zone2 = prediction.numbers.filter(num => num > 20 && num <= 40).length;
            const zone3 = prediction.numbers.filter(num => num > 40 && num <= 60).length;
            const zone4 = prediction.numbers.filter(num => num > 60).length;
            
            const statsContainer = document.createElement('div');
            statsContainer.className = 'grid grid-cols-2 gap-2 text-sm mb-4';
            
            statsContainer.innerHTML = `
                <div class="bg-gray-50 p-2 rounded">
                    <span class="block text-gray-500">01-20区:</span>
                    <span class="font-medium">${zone1} (${(zone1/20*100).toFixed(1)}%)</span>
                </div>
                <div class="bg-gray-50 p-2 rounded">
                    <span class="block text-gray-500">21-40区:</span>
                    <span class="font-medium">${zone2} (${(zone2/20*100).toFixed(1)}%)</span>
                </div>
                <div class="bg-gray-50 p-2 rounded">
                    <span class="block text-gray-500">41-60区:</span>
                    <span class="font-medium">${zone3} (${(zone3/20*100).toFixed(1)}%)</span>
                </div>
                <div class="bg-gray-50 p-2 rounded">
                    <span class="block text-gray-500">61-80区:</span>
                    <span class="font-medium">${zone4} (${(zone4/20*100).toFixed(1)}%)</span>
                </div>`;
            
            detailCard.appendChild(statsContainer);
            
            // 添加准确率信息
            const accuracyInfo = document.createElement('div');
            accuracyInfo.className = 'bg-gray-50 p-3 rounded';
            
            if (prediction.accuracy === '--') {
                accuracyInfo.innerHTML = `
                    <p class="text-sm text-gray-700">预测状态: 尚未验证</p>
                    <button id="markResultBtn" class="mt-2 bg-primary hover:bg-primary/90 text-white px-3 py-1 rounded text-sm transition-all">
                        <i class="fa fa-check-circle mr-1"></i> 标记结果
                    </button>
                `;
                
                // 绑定标记结果按钮事件
                setTimeout(() => {
                    const markBtn = document.getElementById('markResultBtn');
                    if (markBtn) {
                        markBtn.addEventListener('click', function() {
                            markPredictionResult(prediction.id);
                        });
                    }
                }, 0);
            } else {
                accuracyInfo.innerHTML = `
                    <p class="text-sm text-gray-700">准确率: <span class="font-medium">${prediction.accuracy}</span></p>
                    <p class="text-sm text-gray-700">正确个数: <span class="font-medium">${prediction.correctCount}/20</span></p>
                `;
            }
            
            detailCard.appendChild(accuracyInfo);
            
            detailedHistory.appendChild(detailCard);
            
            // 显示历史模态框
            document.getElementById('historyModal').classList.remove('hidden');
        }

        // 标记预测结果
        function markPredictionResult(predictionId) {
            // 查找预测记录
            const prediction = localState.predictionHistory.find(p => p.id === predictionId);
            if (!prediction) {
                console.error('未找到预测记录:', predictionId);
                return;
            }
            
            // 如果有预测期号，尝试从历史开奖数据中查找对应结果
            if (prediction.period && localState.kl8HistoryData) {
                const drawResult = localState.kl8HistoryData.find(d => d.period === prediction.period);
                if (drawResult) {
                    // 使用实际开奖数据计算真实准确率
                    const result = savePredictionComparisonResult(predictionId, drawResult);
                    if (result) {
                        // 重新加载详情
                        viewPredictionDetails(prediction);
                        showNotification('预测结果已根据实际开奖数据标记', 'success');
                    }
                    return;
                }
            }
            
            // 如果没有对应期号的开奖数据，让用户手动输入开奖号码
            const actualNumbersStr = prompt('请输入开奖号码（用逗号分隔，例如：1,2,3,4,5）');
            
            if (actualNumbersStr) {
                try {
                    // 解析用户输入的号码
                    const actualNumbers = actualNumbersStr.split(',').map(n => Number(n.trim())).filter(n => !isNaN(n));
                    
                    if (actualNumbers.length > 0) {
                        // 计算真实的匹配结果
                        const comparison = comparePredictionWithResult(prediction.numbers, actualNumbers);
                        
                        // 更新预测记录
                        prediction.correctCount = comparison.matchedCount;
                        prediction.accuracy = comparison.accuracy + '%';
                        prediction.actualNumbers = actualNumbers;
                        prediction.comparisonDate = new Date().toLocaleString('zh-CN');
                        prediction.manualInput = true;
                        
                        // 保存更新后的历史记录
                        savePredictionHistory();
                        updateHistoryTable();
                        
                        // 重新加载详情
                        viewPredictionDetails(prediction);
                        
                        showNotification('预测结果已手动标记', 'success');
                    } else {
                        showNotification('请输入有效的开奖号码', 'error');
                    }
                } catch (error) {
                    console.error('处理开奖号码失败:', error);
                    showNotification('处理开奖号码时发生错误', 'error');
                }
            }
        }

        // 导出历史记录
        function exportHistory() {
            if (localState.predictionHistory.length === 0) {
                showNotification('暂无历史记录可导出', 'warning');
                return;
            }
            
            try {
                // 将历史记录转换为JSON字符串
                const historyJson = JSON.stringify(localState.predictionHistory, null, 2);
                
                // 创建Blob对象
                const blob = new Blob([historyJson], { type: 'application/json' });
                
                // 创建下载链接
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = '快乐8预测历史_' + new Date().toLocaleDateString('zh-CN').replace(/\//g, '-') + '.json';
                
                // 触发下载
                document.body.appendChild(a);
                a.click();
                
                // 清理
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('历史记录已导出', 'success');
            } catch (error) {
                console.error('导出历史记录失败:', error);
                showNotification('导出失败，请重试', 'error');
            }
        }

        // 显示通知
        function showNotification(message, type = 'info') {
            // 创建通知元素
            const notification = document.createElement('div');
            
            // 设置样式和内容
            notification.className = 'fixed top-4 right-4 px-4 py-3 rounded-md shadow-lg z-50 transition-all duration-300 transform translate-y-[-20px] opacity-0';

            // 根据类型设置不同颜色
            switch (type) {
                case 'success':
                    notification.classList.add('bg-success/10', 'border', 'border-success/30', 'text-success');
                    notification.innerHTML = '<i class="fa fa-check-circle mr-2"></i>' + message;
                    break;
                case 'warning':
                    notification.classList.add('bg-warning/10', 'border', 'border-warning/30', 'text-warning');
                    notification.innerHTML = '<i class="fa fa-exclamation-triangle mr-2"></i>' + message;
                    break;
                case 'error':
                    notification.classList.add('bg-danger/10', 'border', 'border-danger/30', 'text-danger');
                    notification.innerHTML = '<i class="fa fa-times-circle mr-2"></i>' + message;
                    break;
                default:
                    notification.classList.add('bg-primary/10', 'border', 'border-primary/30', 'text-primary');
                    notification.innerHTML = '<i class="fa fa-info-circle mr-2"></i>' + message;
            }
            
            // 添加到文档
            document.body.appendChild(notification);
            
            // 显示通知
            setTimeout(() => {
                notification.classList.remove('translate-y-[-20px]', 'opacity-0');
            }, 10);
            
            // 自动关闭
            setTimeout(() => {
                notification.classList.add('translate-y-[-20px]', 'opacity-0');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // 加载历史数据
        function loadKl8HistoryData() {
            return new Promise((resolve, reject) => {
                console.log('开始加载快乐8历史数据...');
                
                // 尝试获取内容元素，但不依赖它
                const contentElement = document.getElementById('kl8HistoryContent');
                if (contentElement) {
                    // 如果元素存在，显示加载状态
                    contentElement.innerHTML = `
                        <div class="flex items-center justify-center h-40 text-gray-400">
                            <i class="fa fa-spinner fa-spin mr-2"></i> 正在加载数据...
                        </div>
                    `;
                }
                
                try {
                    // 直接使用备份数据
                    const simpleCreateData = [
                        // 现有数据保持不变
                        { period: "2025290", numbers: ["08", "09", "10", "19", "20", "25", "26", "30", "32", "35", "40", "41", "45", "47", "59", "51", "54", "65", "68", "75"] },
                        { period: "2025289", numbers: ["03", "06", "07", "10", "11", "13", "14", "15", "31", "35", "40", "41", "43", "45", "55", "57", "66", "72", "73", "75"] },
                        { period: "2025288", numbers: ["04", "11", "15", "16", "22", "32", "37", "46", "47", "49", "51", "53", "54", "55", "60", "62", "70", "72", "73", "74"] },
                        { period: "2025287", numbers: ["01", "06", "17", "18", "21", "22", "23", "24", "31", "32", "40", "43", "48", "49", "52", "57", "58", "60", "68", "79"] },
                        { period: "2025286", numbers: ["06", "12", "14", "16", "22", "24", "25", "34", "38", "39", "41", "42", "43", "54", "57", "58", "61", "62", "68", "74"] },
                        { period: "2025285", numbers: ["05", "06", "07", "09", "11", "19", "24", "27", "28", "29", "38", "39", "41", "45", "46", "63", "67", "68", "73", "80"] },
                        { period: "2025284", numbers: ["10", "11", "14", "19", "20", "26", "29", "30", "35", "37", "40", "41", "45", "46", "59", "68", "70", "77", "78", "80"] },
                        { period: "2025283", numbers: ["02", "04", "13", "19", "20", "23", "29", "31", "37", "40", "47", "52", "53", "54", "55", "63", "64", "65", "68", "69"] },
                        { period: "2025282", numbers: ["05", "09", "12", "15", "16", "20", "22", "24", "26", "30", "35", "38", "39", "47", "49", "56", "62", "66", "72", "74"] },
                        { period: "2025281", numbers: ["08", "15", "23", "24", "28", "34", "35", "36", "38", "43", "45", "49", "51", "53", "64", "67", "69", "71", "74", "75"] },
                        { period: "2025280", numbers: ["06", "10", "14", "15", "16", "25", "32", "36", "46", "49", "50", "59", "64", "68", "70", "72", "73", "77", "78", "79"] },
                        { period: "2025279", numbers: ["01", "05", "06", "14", "25", "32", "35", "40", "45", "47", "53", "62", "63", "67", "68", "70", "71", "72", "75", "78"] },
                        { period: "2025278", numbers: ["04", "05", "07", "08", "10", "15", "17", "18", "22", "26", "30", "33", "39", "42", "48", "50", "63", "68", "72", "77"] },
                        { period: "2025277", numbers: ["09", "11", "13", "14", "20", "22", "39", "43", "48", "52", "54", "55", "57", "64", "68", "69", "72", "73", "75", "80"] },
                        { period: "2025276", numbers: ["03", "17", "21", "22", "24", "30", "33", "34", "41", "44", "45", "47", "48", "59", "61", "68", "69", "76", "78", "79"] },
                        { period: "2025275", numbers: ["07", "09", "13", "14", "28", "32", "33", "34", "35", "37", "48", "50", "51", "56", "57", "59", "65", "69", "72", "76"] },
                        { period: "2025274", numbers: ["02", "03", "10", "18", "26", "31", "33", "34", "46", "49", "50", "51", "54", "55", "60", "62", "74", "75", "76", "80"] },
                        { period: "2025273", numbers: ["08", "09", "11", "13", "14", "18", "20", "24", "28", "30", "31", "32", "38", "39", "40", "46", "62", "64", "69", "70"] },
                        { period: "2025272", numbers: ["03", "06", "09", "10", "11", "13", "14", "16", "20", "22", "25", "43", "47", "50", "60", "61", "62", "68", "73", "79"] },
                        { period: "2025271", numbers: ["01", "03", "07", "15", "17", "20", "27", "37", "41", "42", "47", "48", "53", "54", "60", "62", "63", "68", "77", "78"] },
                        { period: "2025270", numbers: ["02", "08", "10", "20", "21", "27", "28", "30", "33", "36", "43", "48", "49", "52", "60", "61", "64", "71", "75", "79"] },  
                        { period: "2025269", numbers: ["01", "08", "10", "15", "19", "20", "24", "30", "33", "43", "49", "50", "56", "57", "60", "67", "70", "73", "78", "80"] },
                        { period: "2025268", numbers: ["05", "12", "16", "18", "19", "26", "31", "33", "38", "39", "41", "42", "49", "54", "59", "64", "65", "70", "73", "77"] },
                        { period: "2025267", numbers: ["08", "13", "20", "21", "25", "34", "37", "39", "45", "47", "50", "57", "58", "60", "65", "71", "72", "75", "78", "79"] },
                        { period: "2025266", numbers: ["01", "05", "09", "13", "16", "17", "25", "28", "29", "33", "34", "38", "45", "47", "48", "55", "62", "71", "73", "78"] },
                        { period: "2025265", numbers: ["02", "09", "11", "16", "18", "27", "28", "35", "36", "38", "49", "52", "54", "60", "62", "64", "66", "72", "77", "78"] },
                        { period: "2025264", numbers: ["06", "10", "15", "16", "20", "24", "25", "28", "34", "35", "37", "38", "42", "44", "45", "49", "54", "66", "69", "80"] },
                        { period: "2025263", numbers: ["04", "05", "11", "13", "14", "20", "23", "24", "27", "32", "33", "42", "45", "55", "58", "62", "64", "70", "79", "80"] },
                        { period: "2025262", numbers: ["08", "10", "14", "19", "27", "31", "33", "40", "42", "44", "46", "47", "49", "54", "58", "60", "67", "70", "75", "77"] },
                        { period: "2025261", numbers: ["03", "10", "15", "17", "19", "22", "23", "25", "31", "35", "36", "42", "60", "61", "62", "65", "70", "73", "76", "77"] },
                        { period: "2025260", numbers: ["03", "08", "10", "11", "13", "16", "21", "24", "27", "38", "41", "48", "54", "58", "59", "61", "62", "66", "69", "71"] },
                        { period: "2025259", numbers: ["04", "07", "09", "19", "20", "30", "33", "35", "44", "45", "48", "49", "50", "51", "52", "70", "71", "72", "74", "78"] },
                        { period: "2025258", numbers: ["01", "05", "10", "12", "16", "23", "25", "28", "29", "36", "40", "46", "51", "55", "58", "64", "66", "71", "76", "80"] },
                        { period: "2025257", numbers: ["01", "08", "13", "15", "22", "34", "36", "38", "42", "43", "49", "50", "51", "65", "66", "67", "70", "71", "79", "80"] },
                        { period: "2025256", numbers: ["08", "13", "18", "29", "34", "35", "39", "41", "43", "45", "46", "47", "57", "64", "68", "71", "73", "74", "75", "78"] },
                        { period: "2025255", numbers: ["05", "13", "15", "21", "25", "26", "27", "31", "37", "39", "46", "50", "54", "56", "57", "59", "65", "70", "78", "79"] },
                        { period: "2025254", numbers: ["16", "18", "20", "29", "32", "36", "37", "41", "52", "53", "54", "55", "56", "57", "65", "69", "70", "74", "75", "76"] },
                        { period: "2025253", numbers: ["03", "10", "20", "23", "27", "30", "32", "35", "44", "48", "50", "51", "53", "56", "57", "63", "65", "68", "70", "72"] },
                        { period: "2025252", numbers: ["13", "18", "19", "26", "27", "30", "33", "37", "41", "43", "47", "49", "53", "58", "61", "64", "68", "71", "73", "76"] },
                        { period: "2025251", numbers: ["01", "02", "04", "14", "15", "23", "25", "26", "27", "30", "36", "39", "42", "44", "46", "52", "55", "62", "65", "66"] },
                        { period: "2025250", numbers: ["01", "02", "06", "16", "20", "21", "23", "26", "27", "29", "30", "34", "40", "43", "59", "63", "65", "71", "79", "80"] },
                        { period: "2025249", numbers: ["01", "06", "07", "12", "13", "15", "21", "25", "27", "30", "36", "40", "41", "45", "55", "57", "67", "72", "73", "77"] },
                        { period: "2025248", numbers: ["06", "10", "21", "22", "28", "29", "32", "33", "34", "37", "43", "49", "51", "52", "55", "56", "57", "59", "67", "80"] },
                        { period: "2025247", numbers: ["01", "03", "05", "06", "10", "11", "14", "23", "25", "32", "35", "36", "50", "51", "57", "58", "65", "72", "73", "76"] },
                        { period: "2025246", numbers: ["01", "04", "08", "11", "26", "27", "30", "37", "46", "53", "55", "57", "62", "64", "65", "69", "72", "78", "79", "80"] },
                        { period: "2025245", numbers: ["02", "07", "08", "11", "17", "19", "21", "22", "26", "28", "31", "40", "43", "44", "53", "63", "71", "74", "76", "80"] },
                        { period: "2025244", numbers: ["02", "03", "06", "10", "12", "16", "23", "25", "28", "29", "34", "35", "38", "42", "44", "47", "58", "64", "73", "80"] },
                        { period: "2025243", numbers: ["01", "04", "07", "18", "22", "25", "29", "30", "34", "37", "43", "49", "51", "53", "54", "55", "57", "67", "75", "77"] },
                        { period: "2025242", numbers: ["02", "08", "11", "13", "15", "16", "20", "21", "23", "26", "35", "53", "65", "66", "69", "72", "73", "78", "79", "80"] },
                        { period: "2025241", numbers: ["03", "07", "12", "13", "16", "18", "20", "28", "37", "47", "48", "50", "53", "61", "63", "68", "69", "75", "76", "80"] },
                        { period: "2025240", numbers: ["08", "09", "11", "12", "15", "27", "35", "36", "43", "45", "49", "50", "51", "61", "64", "65", "68", "72", "78", "79"] },
                        { period: "2025239", numbers: ["02", "03", "10", "12", "15", "21", "22", "27", "34", "35", "37", "38", "49", "51", "55", "65", "66", "70", "71", "76"] }
                    ];
                    
                    // 使用去重排序函数确保数据格式正确
                    localState.kl8HistoryData = deduplicateAndSortData(simpleCreateData);
                    
                    // 标记数据已加载
                    localState.isDataLoaded = true;
                    
                    // 在页面上显示数据加载状态和统计信息
                    const statusElement = document.createElement('div');
                    statusElement.className = 'fixed bottom-4 right-4 bg-green-500 text-white px-4 py-2 rounded shadow-lg z-50';
                    statusElement.innerHTML = `
                        <div>数据加载成功</div>
                        <div>共加载 ${localState.kl8HistoryData.length} 期数据</div>
                        <div>最早期号: ${localState.kl8HistoryData[localState.kl8HistoryData.length - 1].period}</div>
                        <div>最新期号: ${localState.kl8HistoryData[0].period}</div>
                    `;
                    document.body.appendChild(statusElement);
                    
                    // 5秒后自动移除状态提示
                    setTimeout(() => {
                        statusElement.remove();
                    }, 5000);
                    
                    // 计算频率数据
                    calculateNumberFrequency();
                    
                    // 更新UI（如果需要）
                    try {
                        renderKl8HistoryData();
                        renderNumberFrequency();
                    } catch (e) {
                        console.log('UI渲染可能在模态框打开前调用，这是正常的:', e);
                    }
                    
                    // 尝试更新更新时间（如果元素存在）
                    const updateTimeElement = document.getElementById('kl8HistoryUpdateTime');
                    if (updateTimeElement) {
                        updateTimeElement.textContent = '数据更新时间: ' + new Date().toLocaleString('zh-CN');
                    }
                    
                    // 尝试更新模型状态（如果元素存在）
                    const modelStatusElement = document.getElementById('modelStatus');
                    const lastUpdatedElement = document.getElementById('lastUpdated');
                    if (modelStatusElement) {
                        modelStatusElement.textContent = '初始化完成';
                        modelStatusElement.className = 'text-success';
                    }
                    if (lastUpdatedElement) {
                        lastUpdatedElement.textContent = new Date().toLocaleString('zh-CN');
                    }
                    
                    // 更新所有位置走势图
                    updateAllPositionCharts();
                    
                    showNotification('历史数据加载成功', 'success');
                    
                    console.log('快乐8历史数据加载成功，共加载', localState.kl8HistoryData.length, '期数据');
                    
                    // 成功完成后解析Promise
                    resolve(localState.kl8HistoryData);
                } catch (error) {
                    console.error('加载快乐8历史数据失败:', error);
                    showNotification('加载数据失败', 'error');
                    
                    // 在页面上显示错误信息
                    const errorElement = document.createElement('div');
                    errorElement.className = 'fixed bottom-4 right-4 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50';
                    errorElement.innerHTML = `
                        <div>数据加载失败</div>
                        <div>${error.message}</div>
                    `;
                    document.body.appendChild(errorElement);
                    
                    // 5秒后自动移除错误提示
                    setTimeout(() => {
                        errorElement.remove();
                    }, 5000);
                    
                    // 失败时拒绝Promise
                    reject(error);
                }
            });
        }
    
    // 计算号码频率分布
    function calculateNumberFrequency() {
        if (!localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
            return { frequencies: {}, totalPeriods: 0, minPeriod: '', maxPeriod: '' };
        }
        
        // 初始化1-80号的出现次数为0
        const frequencies = {};
        for (let i = 1; i <= 80; i++) {
            const number = i.toString().padStart(2, '0');
            frequencies[number] = 0;
        }
        
        // 统计每个号码出现的次数
        for (const periodData of localState.kl8HistoryData) {
            for (const number of periodData.numbers) {
                if (frequencies.hasOwnProperty(number)) {
                    frequencies[number]++;
                }
            }
        }
        
        const totalPeriods = localState.kl8HistoryData.length;
        
        // 获取数据范围
        const periods = localState.kl8HistoryData.map(item => parseInt(item.period));
        const minPeriod = Math.min(...periods).toString();
        const maxPeriod = Math.max(...periods).toString();
        
        return { frequencies, totalPeriods, minPeriod, maxPeriod };
    }
    
    // 渲染号码频率分布
    function renderNumberFrequency() {
        const { frequencies, totalPeriods, minPeriod, maxPeriod } = calculateNumberFrequency();
        
        // 更新统计信息
        document.getElementById('frequencyDataRange').textContent = minPeriod + '-' + maxPeriod;
        document.getElementById('totalPeriods').textContent = totalPeriods;
        
        // 准备图表数据
        const labels = Object.keys(frequencies);
        const data = Object.values(frequencies);
        const maxFrequency = Math.max(...data);
        
        // 清空之前的图表
        const ctx = document.getElementById('numberFrequencyChart');
        if (window.frequencyChartInstance) {
            window.frequencyChartInstance.destroy();
        }
        
        // 创建新图表
        window.frequencyChartInstance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: '出现次数',
                    data: data,
                    backgroundColor: data.map(count => {
                        const percentage = count / maxFrequency;
                        if (percentage > 0.8) return 'rgba(245, 63, 63, 0.7)'; // 高频率 - 红色
                        if (percentage > 0.5) return 'rgba(255, 125, 0, 0.7)'; // 中高频率 - 橙色
                        if (percentage > 0.3) return 'rgba(255, 205, 86, 0.7)'; // 中频率 - 黄色
                        return 'rgba(22, 93, 255, 0.7)'; // 低频率 - 蓝色
                    }),
                    borderColor: data.map(count => {
                        const percentage = count / maxFrequency;
                        if (percentage > 0.8) return 'rgba(245, 63, 63, 1)';
                        if (percentage > 0.5) return 'rgba(255, 125, 0, 1)';
                        if (percentage > 0.3) return 'rgba(255, 205, 86, 1)';
                        return 'rgba(22, 93, 255, 1)';
                    }),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const number = context.label;
                                const count = context.raw;
                                const frequency = ((count / totalPeriods) * 100).toFixed(1);
                                return number + ': 出现' + count + '次 (' + frequency + '%)';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    },
                    x: {
                        ticks: {
                            autoSkip: true,
                            maxRotation: 0,
                            callback: function(value, index, values) {
                                // 只显示部分标签，避免拥挤
                                if (index % 5 === 0) {
                                    return this.getLabelForValue(value);
                                }
                                return '';
                            }
                        }
                    }
                }
            }
        });
        
        // 渲染频率表格
        const tableBody = document.querySelector('#numberFrequencyTable tbody');
        
        // 创建数据数组并按频率降序排序
        const frequencyArray = Object.entries(frequencies)
            .map(([number, count]) => ({
                number,
                count,
                frequency: ((count / totalPeriods) * 100).toFixed(1)
            }))
            .sort((a, b) => b.count - a.count);
        
        // 清空表格
        tableBody.innerHTML = '';
        
        // 添加行
        frequencyArray.forEach(({ number, count, frequency }) => {
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50';
            
            // 计算频率百分比宽度
            const percentage = (count / maxFrequency) * 100;
            
            // 根据频率设置颜色
            let barColor = '#165DFF'; // 蓝色 - 低频率
            if (percentage > 80) barColor = '#F53F3F'; // 红色 - 高频率
            else if (percentage > 50) barColor = '#FF7D00'; // 橙色 - 中高频率
            else if (percentage > 30) barColor = '#FFCD56'; // 黄色 - 中频率
            
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-dark">${number}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${count}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${frequency}%</td>
                <td class="px-6 py-4 whitespace-nowrap">
                    <div class="w-full bg-gray-200 rounded-full h-2">
                        <div class="h-2 rounded-full" style="width: ${percentage}%; background-color: ${barColor}"></div>
                    </div>
                </td>
            `;
            
            tableBody.appendChild(row);
        });
    }
        
            
            // 初始化位置走势图
            initPositionCharts();
        
        // 初始化单个位置的走势图
        // 当前显示的起始索引和每页显示期数
        let chartDisplayPageSize = 18; // 每页显示18期
        let currentPage = 1; // 当前页码
        let chartDisplayStartIndex = 0; // 兼容旧代码，将从currentPage计算得出
        
        // 分页按钮事件处理
        function setupPaginationButtons() {
            const scrollLeftBtn = document.getElementById('scrollLeftBtn');
            const scrollRightBtn = document.getElementById('scrollRightBtn');
            const chartPageInfo = document.getElementById('chartPageInfo');
            
            if (!scrollLeftBtn || !scrollRightBtn || !chartPageInfo) {
                return;
            }
            
            // 上一页按钮点击事件
            scrollLeftBtn.addEventListener('click', function() {
                if (currentPage > 1) {
                    currentPage--;
                    // 从currentPage计算起始索引
                    chartDisplayStartIndex = (currentPage - 1) * chartDisplayPageSize;
                    updateAllPositionCharts(chartDisplayPageSize);
                    updatePaginationButtonsState();
                }
            });
            
            // 下一页按钮点击事件
            scrollRightBtn.addEventListener('click', function() {
                if (localState.kl8HistoryData) {
                    const totalPages = Math.max(1, Math.ceil(localState.kl8HistoryData.length / chartDisplayPageSize));
                    if (currentPage < totalPages) {
                        currentPage++;
                        // 从currentPage计算起始索引
                        chartDisplayStartIndex = (currentPage - 1) * chartDisplayPageSize;
                        updateAllPositionCharts(chartDisplayPageSize);
                        updatePaginationButtonsState();
                    }
                }
            });
        }
        
        // 更新分页按钮状态
        function updatePaginationButtonsState() {
            const scrollLeftBtn = document.getElementById('scrollLeftBtn');
            const scrollRightBtn = document.getElementById('scrollRightBtn');
            const chartPageInfo = document.getElementById('chartPageInfo');
            
            if (!scrollLeftBtn || !scrollRightBtn || !chartPageInfo) {
                return;
            }
            
            // 更新上一页按钮状态
            scrollLeftBtn.disabled = currentPage === 1;
            
            // 更新下一页按钮状态
            const totalPages = localState.kl8HistoryData ? 
                              Math.max(1, Math.ceil(localState.kl8HistoryData.length / chartDisplayPageSize)) : 1;
            scrollRightBtn.disabled = currentPage >= totalPages;
            
            // 更新页码信息
            chartPageInfo.textContent = `第 ${currentPage} 页 / 共 ${totalPages} 页`;
            
            // 同步更新滑动条状态
            if (typeof updateChartSlider === 'function') {
                updateChartSlider();
            }
        }
        
        // 初始化滚动按钮
        setupPaginationButtons();
        
        // 初始化滑动条 - 为每个号位图表单独添加滑动条
        // 滑动条功能已移除，使用分页显示功能
        
        // 清理页面上可能存在的滑动条元素
        function cleanupSliders() {
            const oldSliders = document.querySelectorAll('[id^="chartScrollContainer"]');
            oldSliders.forEach(container => container.remove());
            
            // 清除所有与滑动条相关的样式
            const oldStyles = document.querySelectorAll('style');
            oldStyles.forEach(style => {
                if (style.textContent && style.textContent.includes('chart-scroll-slider')) {
                    style.remove();
                }
            });
        }
        
        // 清理旧的滑动条元素
        cleanupSliders();
        
        // 初始化分页按钮
        setupPaginationButtons();
        
        function initPositionChart(position) {
            const ctx = document.getElementById('positionChart' + position).getContext('2d');
            const canvas = ctx.canvas;
            
            // 为不同位置选择不同的颜色
            const colors = [
                '#722ED1', '#165DFF', '#36CFC9', '#FFC53D', '#F53F3F',
                '#722ED1', '#165DFF', '#36CFC9', '#FFC53D', '#F53F3F',
                '#722ED1', '#165DFF', '#36CFC9', '#FFC53D', '#F53F3F',
                '#722ED1', '#165DFF', '#36CFC9', '#FFC53D', '#F53F3F'
            ];
            const numberColor = colors[position - 1];
            
            // 准备数据和期号
            let positionNumbers = [];
            let drawDates = [];
            
            // 获取历史数据，支持所有期数记录和分页显示
            if (localState.kl8HistoryData && localState.kl8HistoryData.length > 0) {
                // 获取总数据长度
                const totalDataLength = localState.kl8HistoryData.length;
                
                // 根据当前页码计算起始索引
                chartDisplayStartIndex = (currentPage - 1) * chartDisplayPageSize;
                
                // 计算结束索引，确保不超出范围
                const endIndex = Math.min(chartDisplayStartIndex + chartDisplayPageSize, totalDataLength);
                
                // 获取当前页的数据，从旧到新排序显示
                // 支持无限制添加新数据，自动适应数据增长
                const displayData = localState.kl8HistoryData.slice(chartDisplayStartIndex, endIndex).reverse();
                
                positionNumbers = displayData.map(item => {
                    if (item.numbers && item.numbers.length >= position) {
                        return parseInt(item.numbers[position - 1]);
                    }
                    return null;
                }).filter(n => n !== null);
                
                // 获取期号数据
                drawDates = displayData.slice(0, positionNumbers.length).map(item => {
                    if (item.period) {
                        // 显示完整期号
                        return item.period;
                    }
                    return '';
                });
            }
            
            // 销毁已存在的图表
            if (localState.positionCharts && localState.positionCharts[position]) {
                localState.positionCharts[position].destroy();
            }
            
            // 确保positionCharts对象存在
            if (!localState.positionCharts) {
                localState.positionCharts = {};
            }
            
            // 创建图表实例
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: drawDates,
                    datasets: [{
                        data: positionNumbers,
                        borderColor: numberColor,
                        backgroundColor: numberColor + '20',
                        pointRadius: 5,
                        pointBackgroundColor: numberColor,
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        borderWidth: 2,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0
                    },
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 40,
                            left: 20,
                            right: 20
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                        enabled: false
                    }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    size: 10
                                },
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            display: true,
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                color: '#666',
                                font: {
                                    size: 10
                                },
                                stepSize: 10
                            },
                            min: 0,
                            max: 80
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                },
                plugins: [{
                    id: 'numberLabels',
                    afterDraw: function(chart) {
                        const ctx = chart.ctx;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillStyle = numberColor;
                        
                        // 绘制号码标签，调整位置避免重叠
                        chart.data.datasets.forEach((dataset, datasetIndex) => {
                            const meta = chart.getDatasetMeta(datasetIndex);
                            meta.data.forEach((point, index) => {
                                const value = dataset.data[index];
                                if (value !== null && value !== undefined) {
                                    // 为避免重叠，在数据点上方添加足够空间
                                    ctx.fillText(value.toString(), point.x, point.y - 10);
                                }
                            });
                        });
                    }
                }]
            });
            
            // 存储图表实例
            localState.positionCharts[position] = chart;
        }
        
        // 强制刷新所有位置图表的函数
        function forceRefreshAllPositionCharts() {
            console.log('强制刷新所有位置图表');
            // 销毁所有现有图表实例
            if (localState.positionCharts) {
                Object.keys(localState.positionCharts).forEach(position => {
                    if (localState.positionCharts[position]) {
                        localState.positionCharts[position].destroy();
                    }
                });
                // 清空positionCharts对象
                localState.positionCharts = {};
            }
            
            // 销毁所有末位号码图表实例
            if (localState.lastDigitCharts) {
                Object.keys(localState.lastDigitCharts).forEach(digit => {
                    if (localState.lastDigitCharts[digit]) {
                        localState.lastDigitCharts[digit].destroy();
                    }
                });
                // 清空lastDigitCharts对象
                localState.lastDigitCharts = {};
            }
            
            // 重新初始化所有图表
            initPositionCharts();
        }
        
        // 暴露给全局作用域，以便在控制台或其他地方调用
        window.forceRefreshCharts = forceRefreshAllPositionCharts;
        
        // 初始化末位号码走势图
        function initLastDigitChart(digit) {
            const ctx = document.getElementById('lastDigitChart' + digit);
            if (!ctx || !localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
                return null;
            }
            
            // 根据当前页码和每页显示数量获取数据
            const totalDataLength = localState.kl8HistoryData.length;
            chartDisplayStartIndex = (currentPage - 1) * chartDisplayPageSize;
            const endIndex = Math.min(chartDisplayStartIndex + chartDisplayPageSize, totalDataLength);
            const displayData = localState.kl8HistoryData.slice(chartDisplayStartIndex, endIndex).reverse();
            
            // 准备期号数据（只显示后三位）
            const drawDates = displayData.map(item => item.period.slice(-3));
            
            // 为每个末位数字获取每期出现的位置
            const positionNumbers = displayData.map(item => {
                if (!item.numbers || item.numbers.length === 0) {
                    return null;
                }
                
                // 找到末位等于digit的第一个号码的位置
                for (let i = 0; i < item.numbers.length; i++) {
                    const number = parseInt(item.numbers[i]);
                    if (number % 10 === digit) {
                        return i + 1; // 返回位置（从1开始）
                    }
                }
                return null; // 如果没有找到，返回null
            });
            
            // 数字颜色根据末位不同变化
            const digitColors = [
                '#FF6384', // 0 - 红色
                '#36A2EB', // 1 - 蓝色
                '#FFCE56', // 2 - 黄色
                '#4BC0C0', // 3 - 青色
                '#9966FF', // 4 - 紫色
                '#FF9F40', // 5 - 橙色
                '#C9CBCF', // 6 - 灰色
                '#4BC0C0', // 7 - 青色
                '#FF6384', // 8 - 红色
                '#36A2EB'  // 9 - 蓝色
            ];
            
            const numberColor = digitColors[digit] || '#165DFF';
            
            // 创建图表实例
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: drawDates,
                    datasets: [{
                        label: `末位${digit}`,
                        data: positionNumbers,
                        backgroundColor: numberColor + '20',
                        borderColor: numberColor,
                        borderWidth: 2,
                        tension: 0.1,
                        pointBackgroundColor: numberColor,
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        },
                        numberLabels: {
                            // 数字标签将通过插件添加
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: {
                                display: true,
                                color: '#f0f0f0'
                            }
                        },
                        y: {
                            display: true,
                            beginAtZero: true,
                            max: 20,
                            ticks: {
                                stepSize: 5
                            },
                            grid: {
                                display: true,
                                color: '#f0f0f0'
                            }
                        }
                    },
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 20
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                },
                plugins: [{
                    id: 'numberLabels',
                    afterDraw: function(chart) {
                        const ctx = chart.ctx;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillStyle = numberColor;
                        
                        // 绘制号码标签，调整位置避免重叠
                        chart.data.datasets.forEach((dataset, datasetIndex) => {
                            const meta = chart.getDatasetMeta(datasetIndex);
                            meta.data.forEach((point, index) => {
                                const value = dataset.data[index];
                                if (value !== null && value !== undefined) {
                                    // 为避免重叠，在数据点上方添加足够空间
                                    ctx.fillText(value.toString(), point.x, point.y - 10);
                                }
                            });
                        });
                    }
                }]
            });
            
            // 存储图表实例
            if (!localState.lastDigitCharts) {
                localState.lastDigitCharts = {};
            }
            localState.lastDigitCharts[digit] = chart;
            
            return chart;
        }
        
        // 初始化所有位置的走势图
        function initPositionCharts() {
            // 确保positionCharts对象存在
            if (!localState.positionCharts) {
                localState.positionCharts = {};
            }
            
            // 确保lastDigitCharts对象存在
            if (!localState.lastDigitCharts) {
                localState.lastDigitCharts = {};
            }
            
            // 初始化所有20个位置的走势图
            for (let i = 1; i <= 20; i++) {
                const ctx = document.getElementById('positionChart' + i);
                if (ctx) {
                    initPositionChart(i);
                }
            }
            
            // 初始化所有末位号码走势图（0-9）
            for (let i = 0; i <= 9; i++) {
                const ctx = document.getElementById('lastDigitChart' + i);
                if (ctx) {
                    initLastDigitChart(i);
                }
            }
            
            // 添加分页切换功能
            const pageButtons = document.querySelectorAll('.position-page-btn');
            pageButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // 获取要显示的页码
                    const page = parseInt(this.getAttribute('data-page'));
                    
                    // 更新按钮状态
                    pageButtons.forEach(btn => {
                        const btnPage = parseInt(btn.getAttribute('data-page'));
                        if (btnPage === page) {
                            btn.classList.add('bg-primary', 'text-white', 'border-primary');
                            btn.classList.remove('border-gray-300', 'text-gray-700', 'hover:bg-gray-50');
                        } else {
                            btn.classList.remove('bg-primary', 'text-white', 'border-primary');
                            btn.classList.add('border-gray-300', 'text-gray-700', 'hover:bg-gray-50');
                        }
                    });
                    
                    // 隐藏所有页面
                    for (let i = 1; i <= 5; i++) {
                        const pageElement = document.getElementById('positionChartsPage' + i);
                        if (pageElement) {
                            pageElement.classList.add('hidden');
                        }
                    }
                    
                    // 显示选中的页面
                    const activePageElement = document.getElementById('positionChartsPage' + page);
                    if (activePageElement) {
                        activePageElement.classList.remove('hidden');
                    }
                });
            });
            
            // 添加期数选择器事件监听
            const periodSelector = document.getElementById('positionChartPeriods');
            if (periodSelector) {
                periodSelector.addEventListener('change', function() {
                    updateAllPositionCharts();
                });
            }
            
            // 添加更新按钮事件监听
            const updateBtn = document.getElementById('updateAllChartsBtn');
            if (updateBtn) {
                updateBtn.addEventListener('click', function() {
                    updateAllPositionCharts();
                });
            }
        }
        
        // 更新指定位置的走势图
        function updatePositionChart(position, numPeriods = 47) {
            // 为了确保修改生效，我们将强制重新创建图表
            if (localState.positionCharts && localState.positionCharts[position]) {
                localState.positionCharts[position].destroy();
                delete localState.positionCharts[position];
            }
            
            // 强制重新初始化图表
            initPositionChart(position);
            
            // 更新分页按钮状态
            updatePaginationButtonsState();
        }
        
        // 增强的位置走势预测函数
        
        // 更新末位号码走势图
        function updateLastDigitChart(digit, numPeriods = 47) {
            // 为了确保修改生效，我们将强制重新创建图表
            if (localState.lastDigitCharts && localState.lastDigitCharts[digit]) {
                localState.lastDigitCharts[digit].destroy();
                delete localState.lastDigitCharts[digit];
            }
            
            // 强制重新初始化图表
            initLastDigitChart(digit);
            
            // 更新分页按钮状态
            updatePaginationButtonsState();
        }
        
        // 更新所有位置的走势图
        function updateAllPositionCharts(numPeriods = 47) {
            // 验证数据和图表存在性
            if (!localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
                console.warn('没有有效的历史数据可供更新');
                return;
            }
            
            // 遍历所有位置更新图表
            if (localState.positionCharts) {
                for (let i = 1; i <= 20; i++) {
                    if (localState.positionCharts[i]) {
                        updatePositionChart(i, numPeriods);
                    }
                }
            }
            
            // 遍历所有末位号码更新图表
            if (localState.lastDigitCharts) {
                for (let i = 0; i <= 9; i++) {
                    if (localState.lastDigitCharts[i]) {
                        updateLastDigitChart(i, numPeriods);
                    }
                }
            }
        }
        
        // 渲染快乐8历史数据
        function renderKl8HistoryData() {
            console.log('开始渲染快乐8历史数据...');
            
            const contentElement = document.getElementById('kl8HistoryContent');
            
            // 检查contentElement是否存在
            if (!contentElement) {
                console.error('未找到kl8HistoryContent元素');
                // 如果元素不存在，尝试查找并创建
                const modalElement = document.getElementById('kl8HistoryModal');
                if (modalElement) {
                    const contentContainer = modalElement.querySelector('div[class*="overflow-y-auto"]');
                    if (contentContainer) {
                        const existingContent = contentContainer.querySelector('#kl8HistoryContent');
                        if (existingContent) {
                            console.log('找到已存在的kl8HistoryContent元素');
                        } else {
                            console.log('在modal中创建kl8HistoryContent元素');
                            const newContentElement = document.createElement('div');
                            newContentElement.id = 'kl8HistoryContent';
                            newContentElement.className = 'space-y-6';
                            contentContainer.innerHTML = '';
                            contentContainer.appendChild(newContentElement);
                        }
                    }
                }
                return;
            }
            
            // 检查数据是否存在
            console.log('localState.kl8HistoryData状态:', {
                exists: !!localState.kl8HistoryData,
                length: localState.kl8HistoryData ? localState.kl8HistoryData.length : 0
            });
            
            if (!localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
                console.log('无历史数据可显示');
                contentElement.innerHTML = `
                    <div class="flex items-center justify-center h-40 text-gray-400">
                        <i class="fa fa-exclamation-circle mr-2"></i> 暂无数据
                    </div>
                `;
                return;
            }
            
            // 只显示最近30期数据
            const displayData = localState.kl8HistoryData.slice(0, 30);
            console.log('将显示的数据期数:', displayData.length);
            
            let html = '';
            
            displayData.forEach((item, index) => {
                const isOddIndex = index % 2 === 1;
                
                html += `
                    <div class="p-4 rounded-lg ${isOddIndex ? 'bg-gray-50' : 'bg-white border border-gray-100'}">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="text-lg font-semibold text-dark">${item.period}期</h3>
                            <span class="text-sm text-gray-500">${new Date().toLocaleDateString('zh-CN')}</span>
                        </div>
                        <div class="flex flex-wrap gap-2">
                `;
                
                // 渲染号码球
                item.numbers.forEach(number => {
                    // 根据号码范围设置不同颜色
                    let ballClass = 'bg-blue-100 text-blue-600';
                    const num = parseInt(number);
                    
                    if (num > 20 && num <= 40) ballClass = 'bg-green-100 text-green-600';
                    else if (num > 40 && num <= 60) ballClass = 'bg-yellow-100 text-yellow-600';
                    else if (num > 60) ballClass = 'bg-red-100 text-red-600';
                    
                    html += `
                        <div class="${ballClass} w-10 h-10 rounded-full flex items-center justify-center font-medium">
                            ${number}
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            // 确保正确更新内容
            console.log('渲染HTML内容完成，长度:', html.length);
            contentElement.innerHTML = html;
            
            // 更新所有位置走势图
            updateAllPositionCharts();
        }

        // 渲染历史数据编辑表单
        function renderKl8HistoryEditForm() {
            const contentElement = document.getElementById('kl8HistoryEditContent');
            
            if (!contentElement || !localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
                contentElement.innerHTML = `
                    <div class="flex items-center justify-center h-40 text-gray-400">
                        <i class="fa fa-exclamation-circle mr-2"></i> 暂无数据可编辑
                    </div>
                `;
                return;
            }
            
            // 只显示最近30期数据用于编辑
            const displayData = localState.kl8HistoryData.slice(0, 30);
            
            let html = `
                <div class="mb-4 p-3 bg-blue-50 rounded-md text-sm text-blue-700">
                    <i class="fa fa-info-circle mr-1"></i> 请编辑历史数据，每行输入20个号码，用空格分隔
                </div>
            `;
            
            displayData.forEach((item, index) => {
                const isOddIndex = index % 2 === 1;
                
                html += `
                    <div class="p-4 rounded-lg ${isOddIndex ? 'bg-gray-50' : 'bg-white border border-gray-100'}">
                        <div class="flex justify-between items-center mb-3">
                            <div class="flex items-center">
                                <h3 class="text-lg font-semibold text-dark mr-2">${item.period}期</h3>
                                <input type="text" id="editPeriod${index}" value="${item.period}" class="border rounded-md px-2 py-1 text-sm w-24">
                            </div>
                            <span class="text-sm text-gray-500">${new Date().toLocaleDateString('zh-CN')}</span>
                        </div>
                        <div class="mb-3">
                            <textarea id="editNumbers${index}" rows="3" class="w-full border rounded-md px-3 py-2" placeholder="请输入20个号码，用空格分隔">${item.numbers.join(' ')}</textarea>
                        </div>
                        <div class="flex flex-wrap gap-2">
                `;
                
                // 渲染当前号码球预览
                item.numbers.forEach(number => {
                    let ballClass = 'bg-blue-100 text-blue-600';
                    const num = parseInt(number);
                    
                    if (num > 20 && num <= 40) ballClass = 'bg-green-100 text-green-600';
                    else if (num > 40 && num <= 60) ballClass = 'bg-yellow-100 text-yellow-600';
                    else if (num > 60) ballClass = 'bg-red-100 text-red-600';
                    
                    html += `
                        <div class="${ballClass} w-8 h-8 rounded-full flex items-center justify-center font-medium text-sm">
                            ${number}
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            contentElement.innerHTML = html;
        }

        // 导入历史数据文件
        function importKl8HistoryData() {
            const fileInput = document.getElementById('kl8HistoryFileInput');
            fileInput.click();
        }
        
        // 处理导入的历史数据文件
        function handleImportedFile(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            
            // 检查文件类型
            if (!file.name.endsWith('.json')) {
                showNotification('请选择JSON格式的文件', 'error');
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(event) {
                try {
                    // 解析JSON文件，确保正确处理UTF-8编码
                    const result = event.target.result;
                    const importedData = JSON.parse(result);
                    
                    // 验证数据格式
                    if (!Array.isArray(importedData)) {
                        showNotification('导入的数据格式不正确', 'error');
                        return;
                    }
                    
                    // 验证数组中的对象格式
                    const validData = importedData.filter(item => 
                        item && typeof item.period === 'string' && Array.isArray(item.numbers)
                    );
                    
                    if (validData.length === 0) {
                        showNotification('未找到有效的历史数据', 'error');
                        return;
                    }
                    
                    // 合并数据并去重排序
                    const mergedData = [...localState.kl8HistoryData, ...validData];
                    localState.kl8HistoryData = deduplicateAndSortData(mergedData);
                    
                    // 更新UI
                    renderKl8HistoryData();
                    
                    // 重新计算频率数据
                    calculateNumberFrequency();
                    renderNumberFrequency();
                    
                    // 更新更新时间
                    document.getElementById('kl8HistoryUpdateTime').textContent = '数据更新时间: ' + new Date().toLocaleString('zh-CN');
                    
                    showNotification('成功导入 ' + validData.length + ' 条历史数据', 'success');
                    
                    console.log('历史数据导入成功，当前数据总量:', localState.kl8HistoryData.length);
                    
                    // 清空文件输入，以便可以再次选择同一个文件
                    event.target.value = '';
                } catch (error) {
                    console.error('解析导入文件失败:', error);
                    showNotification('解析文件失败，请检查文件格式', 'error');
                    
                    // 清空文件输入
                    event.target.value = '';
                }
            };
            
            reader.onerror = function() {
                showNotification('读取文件失败', 'error');
                
                // 清空文件输入
                event.target.value = '';
            };
            
            // 读取文件内容
            reader.readAsText(file);
        }
        
        // 保存编辑后的历史数据
        function saveEditedKl8HistoryData() {
            if (!localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
                showNotification('暂无数据可保存', 'error');
                return;
            }
            
            const displayDataLength = Math.min(localState.kl8HistoryData.length, 30);
            let hasErrors = false;
            const updatedData = [...localState.kl8HistoryData];
            
            for (let i = 0; i < displayDataLength; i++) {
                const periodInput = document.getElementById('editPeriod' + i);
                const numbersInput = document.getElementById('editNumbers' + i);
                
                if (!periodInput || !numbersInput) continue;
                
                const period = periodInput.value.trim();
                const numbersStr = numbersInput.value.trim();
                
                // 验证期号
                if (!period || !/^\d+$/.test(period)) {
                    showNotification('第' + (i+1) + '期：期号格式错误，只能包含数字', 'error');
                    hasErrors = true;
                    continue;
                }
                
                // 验证号码
                const numbers = numbersStr.split(/\s+/).filter(num => num);
                
                if (numbers.length !== 20) {
                    showNotification('第' + (i+1) + '期：必须输入20个号码', 'error');
                    hasErrors = true;
                    continue;
                }
                
                // 验证每个号码
                for (const num of numbers) {
                    if (!/^\d+$/.test(num) || parseInt(num) < 1 || parseInt(num) > 80) {
                        showNotification('第' + (i+1) + '期：号码' + num + '格式错误，必须是1-80之间的数字', 'error');
                        hasErrors = true;
                        break;
                    }
                }
                
                if (hasErrors) continue;
                
                // 更新数据
                updatedData[i] = {
                    period: period,
                    numbers: numbers.map(num => num.padStart(2, '0')) // 确保两位数格式
                };
            }
            
            if (hasErrors) {
                showNotification('请修正错误后再保存', 'error');
                return;
            }
            
            // 保存更新后的数据
            localState.kl8HistoryData = updatedData;
            
            // 重新计算频率数据
            calculateNumberFrequency();
            renderNumberFrequency();
            
            // 更新更新时间
            document.getElementById('kl8HistoryUpdateTime').textContent = '数据更新时间: ' + new Date().toLocaleString('zh-CN');
            
            // 渲染更新后的历史数据
            renderKl8HistoryData();
            
            // 关闭编辑模态框
            document.getElementById('kl8HistoryEditModal').classList.add('hidden');
            
            // 显示成功通知
            showNotification('历史数据已成功保存', 'success');
        }
        
        // 数据对比功能
        function comparePredictions() {
            const predictionHistory = loadPredictionHistory();
            if (!predictionHistory || predictionHistory.length === 0) {
                showNotification('暂无预测历史数据可供对比', 'error');
                return;
            }
            
            // 按预测方法分组统计
            const methodStats = {};
            predictionHistory.forEach(prediction => {
                if (!methodStats[prediction.method]) {
                    methodStats[prediction.method] = {
                        total: 0,
                        correct: 0,
                        predictions: []
                    };
                }
                methodStats[prediction.method].total++;
                methodStats[prediction.method].correct += prediction.correctCount || 0;
                methodStats[prediction.method].predictions.push(prediction);
            });
            
            // 显示对比结果
            renderComparisonResult(methodStats, predictionHistory);
        }
        
        function renderComparisonResult(methodStats, allPredictions) {
            const contentElement = document.getElementById('comparisonContent');
            if (!contentElement) return;
            
            // 计算总体统计
            const totalPredictions = allPredictions.length;
            const totalCorrect = allPredictions.reduce((sum, pred) => sum + (pred.correctCount || 0), 0);
            const avgAccuracy = totalPredictions > 0 ? (totalCorrect / (totalPredictions * 20) * 100).toFixed(2) : 0;
            
            let html = `
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-2">总体统计</h3>
                    <div class="grid grid-cols-3 gap-4">
                        <div class="bg-blue-50 p-4 rounded-lg">
                            <p class="text-sm text-blue-700 mb-1">总预测次数</p>
                            <p class="text-2xl font-bold text-blue-900">${totalPredictions}</p>
                        </div>
                        <div class="bg-green-50 p-4 rounded-lg">
                            <p class="text-sm text-green-700 mb-1">平均准确率</p>
                            <p class="text-2xl font-bold text-green-900">${avgAccuracy}%</p>
                        </div>
                        <div class="bg-purple-50 p-4 rounded-lg">
                            <p class="text-sm text-purple-700 mb-1">最高准确率</p>
                            <p class="text-2xl font-bold text-purple-900">${getMaxAccuracy(allPredictions)}%</p>
                        </div>
                    </div>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-4">预测方法对比</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white rounded-lg overflow-hidden">
                            <thead class="bg-gray-100">
                                <tr>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">预测方法</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">预测次数</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">平均准确率</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">最高准确率</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">最近表现</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-200">
            `;
            
            // 添加各方法的对比数据
            Object.keys(methodStats).forEach(method => {
                const stats = methodStats[method];
                const accuracy = stats.total > 0 ? (stats.correct / (stats.total * 20) * 100).toFixed(2) : 0;
                const methodName = getMethodDisplayName(method);
                const recentPredictions = stats.predictions.slice(-5);
                const recentAccuracy = recentPredictions.length > 0 ? 
                    (recentPredictions.reduce((sum, pred) => sum + (pred.correctCount || 0), 0) / (recentPredictions.length * 20) * 100).toFixed(2) : 0;
                
                html += `
                    <tr class="hover:bg-gray-50">
                        <td class="px-4 py-3 text-sm text-gray-900">${methodName}</td>
                        <td class="px-4 py-3 text-sm text-gray-900">${stats.total}</td>
                        <td class="px-4 py-3 text-sm">
                            <div class="flex items-center">
                                <div class="w-24 bg-gray-200 rounded-full h-2.5 mr-2">
                                    <div class="bg-blue-600 h-2.5 rounded-full" style="width: ${Math.min(accuracy, 100)}%"></div>
                                </div>
                                <span class="text-gray-900">${accuracy}%</span>
                            </div>
                        </td>
                        <td class="px-4 py-3 text-sm text-gray-900">${getMaxAccuracy(stats.predictions)}%</td>
                        <td class="px-4 py-3 text-sm text-gray-900">${recentAccuracy}%</td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold mb-4">近期预测趋势</h3>
                    <div class="h-64 w-full">
                        <canvas id="accuracyTrendChart"></canvas>
                    </div>
                </div>
            `;
            
            contentElement.innerHTML = html;
            
            // 渲染趋势图表
            renderAccuracyTrendChart(allPredictions.slice(-20));
            
            // 显示模态框
            document.getElementById('dataComparisonModal').classList.remove('hidden');
        }
        
        function getMaxAccuracy(predictions) {
            if (!predictions || predictions.length === 0) return 0;
            
            let maxAccuracy = 0;
            predictions.forEach(pred => {
                const accuracy = pred.correctCount ? (pred.correctCount / 20 * 100).toFixed(2) : 0;
                maxAccuracy = Math.max(maxAccuracy, parseFloat(accuracy));
            });
            
            return maxAccuracy.toFixed(2);
        }
        
        function getMethodDisplayName(method) {
            const methodMap = {
                'smart': '智能预测',
                'balanced': '平衡分区',
                'frequency': '频率预测'
            };
            return methodMap[method] || method;
        }
        
        function renderAccuracyTrendChart(predictions) {
            const ctx = document.getElementById('accuracyTrendChart');
            if (!ctx) return;
            
            // 准备图表数据
            const labels = predictions.map((pred, index) => '预测' + (index + 1));
            const smartData = [];
            const balancedData = [];
            const frequencyData = [];
            const similarityFrequencyData = [];
            
            predictions.forEach(pred => {
                const accuracy = pred.correctCount ? (pred.correctCount / 20 * 100) : 0;
                
                if (pred.method === 'smart') smartData.push(accuracy);
                else if (pred.method === 'balanced') balancedData.push(accuracy);
                else if (pred.method === 'frequency') frequencyData.push(accuracy);
                else if (pred.method === 'similarityFrequency') {
                    similarityFrequencyData.push(accuracy);
                }
            });
            
            // 创建图表
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: '智能预测',
                            data: smartData,
                            borderColor: '#722ED1',
                            backgroundColor: 'rgba(114, 46, 209, 0.1)',
                            tension: 0.3,
                            fill: false
                        },
                        { label: '平衡分区',
                            data: balancedData,
                            borderColor: '#165DFF',
                            backgroundColor: 'rgba(22, 93, 255, 0.1)',
                            tension: 0.3,
                            fill: false
                        },
                        { label: '频率预测',
                            data: frequencyData,
                            borderColor: '#00B42A',
                            backgroundColor: 'rgba(0, 180, 42, 0.1)',
                            tension: 0.3,
                            fill: false
                        },
                        { label: '历史相似性预测',
                            data: similarityFrequencyData || [],
                            borderColor: '#FF7D00',
                            backgroundColor: 'rgba(255, 125, 0, 0.1)',
                            tension: 0.3,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: '准确率 (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '预测记录'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        legend: {
                            position: 'top'
                        }
                    }
                }
            });
        }
        
        // 导出对比报告
        function exportComparisonReport() {
            const predictionHistory = loadPredictionHistory();
            if (!predictionHistory || predictionHistory.length === 0) {
                showNotification('暂无预测历史数据可供导出', 'error');
                return;
            }
            
            // 准备报告数据
            const report = {
                exportDate: new Date().toISOString(),
                totalPredictions: predictionHistory.length,
                predictionHistory: predictionHistory,
                statistics: calculatePredictionStats(predictionHistory)
            };
            
            // 转换为CSV格式
            const csvContent = convertToCSV(report);
            
            // 创建下载链接
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', '预测对比报告_' + new Date().toLocaleDateString('zh-CN').replace(/\//g, '-') + '.csv');
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotification('预测对比报告已成功导出', 'success');
        }
        
        function calculatePredictionStats(predictions) {
            const stats = {};
            
            // 按方法统计
            predictions.forEach(pred => {
                if (!stats[pred.method]) {
                    stats[pred.method] = {
                        total: 0,
                        correct: 0
                    };
                }
                stats[pred.method].total++;
                stats[pred.method].correct += pred.correctCount || 0;
            });
            
            // 计算准确率
            Object.keys(stats).forEach(method => {
                stats[method].accuracy = stats[method].total > 0 ? 
                    (stats[method].correct / (stats[method].total * 20) * 100).toFixed(2) : 0;
                stats[method].displayName = getMethodDisplayName(method);
            });
            
            return stats;
        }
        
        function convertToCSV(report) {
            const headers = ['预测时间', '预测方法', '预测号码', '正确数量', '准确率', '是否标记'];
            let csv = headers.join(',') + '\n';
            
            report.predictionHistory.forEach(pred => {
                const date = new Date(pred.timestamp).toLocaleString('zh-CN');
                const method = getMethodDisplayName(pred.method);
                const numbers = pred.predictedNumbers.join(',');
                const correctCount = pred.correctCount || 0;
                const accuracy = ((pred.correctCount || 0) / 20 * 100).toFixed(2);
                const isMarked = pred.correctCount !== undefined ? '是' : '否';
                
                csv += [date, method, numbers, correctCount, accuracy, isMarked].join(',') + '\n';
            });
            
            // 添加统计信息
            csv += '\n\n统计信息\n';
            csv += ['预测方法', '预测次数', '平均准确率'].join(',') + '\n';
            
            Object.values(report.statistics).forEach(stat => {
                csv += [stat.displayName, stat.total, stat.accuracy].join(',') + '\n';
            });
            
            return csv;
        }
        
        // 更新AI预测模型
        function updateAIPrediction() {
            showNotification('AI预测模型正在更新中...', 'info');
            
            // 重新计算频率数据
            if (localState.kl8HistoryData && localState.kl8HistoryData.length > 0) {
                calculateNumberFrequency();
                
                // 更新图表
                renderNumberFrequency();
                
                // 更新模型状态
                document.getElementById('modelStatus').textContent = '已更新';
                document.getElementById('modelStatus').className = 'text-success';
                document.getElementById('lastUpdated').textContent = new Date().toLocaleString('zh-CN');
                
                showNotification('AI预测模型更新成功', 'success');
            } else {
                showNotification('没有足够的历史数据来更新AI模型', 'error');
            }
        }
        
        // 数据去重和排序处理
        function deduplicateAndSortData(data) {
            // 去重处理并验证数据格式
            const uniqueData = [];
            const seenPeriods = new Set();
            
            console.log('deduplicateAndSortData - 原始数据长度:', data.length);
            
            for (const item of data) {
                // 数据验证
                if (!item || typeof item !== 'object' || !item.period || !item.numbers || !Array.isArray(item.numbers)) {
                    console.warn('无效的数据项:', item);
                    continue;
                }
                
                // 验证号码格式
                const validNumbers = item.numbers.filter(num => 
                    typeof num === 'string' && /^\d{1,2}$/.test(num) && parseInt(num) >= 1 && parseInt(num) <= 80
                );
                
                if (validNumbers.length !== 20) {
                    console.warn('数据项 ' + item.period + ' 号码数量不正确: ' + validNumbers.length + '/20');
                    continue;
                }
                
                // 去重
                if (!seenPeriods.has(item.period)) {
                    seenPeriods.add(item.period);
                    uniqueData.push({
                        period: item.period,
                        numbers: validNumbers.map(num => num.padStart(2, '0')) // 确保两位数格式
                    });
                }
            }
            
            // 按期号降序排序
            uniqueData.sort((a, b) => {
                const periodA = parseInt(a.period);
                const periodB = parseInt(b.period);
                return periodB - periodA;
            });
            
            console.log('deduplicateAndSortData - 处理后数据长度:', uniqueData.length);
            return uniqueData;
        }

        // 添加新的历史数据
        function addNewKl8HistoryData() {
            const periodInput = document.getElementById('newPeriod');
            const numbersInput = document.getElementById('newNumbers');
            
            if (!periodInput || !numbersInput) return;
            
            const period = periodInput.value.trim();
            const numbersStr = numbersInput.value.trim();
            
            // 验证期号
            if (!period || !/^\d+$/.test(period)) {
                showNotification('期号格式错误，只能包含数字', 'error');
                return;
            }
            
            // 验证号码
            const numbers = numbersStr.split(/\s+/).filter(num => num);
            
            if (numbers.length !== 20) {
                showNotification('必须输入20个号码', 'error');
                return;
            }
            
            // 验证每个号码
            for (const num of numbers) {
                if (!/^\d+$/.test(num) || parseInt(num) < 1 || parseInt(num) > 80) {
                    showNotification('号码' + num + '格式错误，必须是1-80之间的数字', 'error');
                    return;
                }
            }
            
            // 创建新数据项
            const newDataItem = {
                period: period,
                numbers: numbers.map(num => num.padStart(2, '0')) // 确保两位数格式
            };
            
            // 添加到历史数据
            if (!localState.kl8HistoryData) {
                localState.kl8HistoryData = [newDataItem];
            } else {
                localState.kl8HistoryData.unshift(newDataItem); // 添加到开头
                
                // 去重处理
                const uniqueData = [];
                const seenPeriods = new Set();
                
                for (const item of localState.kl8HistoryData) {
                    if (!seenPeriods.has(item.period)) {
                        seenPeriods.add(item.period);
                        uniqueData.push(item);
                    }
                }
                
                // 按期号降序排序
                uniqueData.sort((a, b) => parseInt(b.period) - parseInt(a.period));
                
                localState.kl8HistoryData = uniqueData;
            }
            
            // 更新UI
            renderKl8HistoryData();
            
            // 关闭添加模态框
            document.getElementById('addKl8HistoryModal').classList.add('hidden');
            
            // 如果编辑模态框是打开的，更新它
            if (!document.getElementById('kl8HistoryEditModal').classList.contains('hidden')) {
                renderKl8HistoryEditForm();
            }
            
            // 显示成功通知
            showNotification('历史数据已成功添加', 'success');
        }
        
        // 初始化事件监听器
        function initEventListeners() {
            // 导入历史数据按钮事件
            document.getElementById('importKl8HistoryBtn').addEventListener('click', function() {
                importKl8HistoryData();
            });
            
            // 历史数据文件输入事件
            document.getElementById('kl8HistoryFileInput').addEventListener('change', handleImportedFile);
            
            // AI更新按钮事件
            document.getElementById('aiUpdateBtn').addEventListener('click', function() {
                updateAIPrediction();
            });
            
            // 数据对比按钮事件
            document.getElementById('dataCompareBtn').addEventListener('click', function() {
                comparePredictions();
            });
            
            // 关闭数据对比模态框
            document.getElementById('closeComparisonModal').addEventListener('click', function() {
                document.getElementById('dataComparisonModal').classList.add('hidden');
            });
            
            // 关闭数据对比模态框（标题栏按钮）
            document.getElementById('closeComparisonModalHeader').addEventListener('click', function() {
                document.getElementById('dataComparisonModal').classList.add('hidden');
            });
            
            // 导出对比报告
            document.getElementById('exportComparisonReport').addEventListener('click', function() {
                exportComparisonReport();
            });
            
            // 相同号码对比按钮事件
            const sameNumbersBtn = document.getElementById('sameNumbersBtn');
            if (sameNumbersBtn) {
                sameNumbersBtn.addEventListener('click', function() {
                    calculateSameNumbersFrequency();
                });
            }
            
            // 预测结果对比按钮事件
            const predictResultCompareBtn = document.getElementById('predictResultCompareBtn');
            if (predictResultCompareBtn) {
                predictResultCompareBtn.addEventListener('click', function() {
                    showPeriodPredictionComparison();
                });
            }
            
            // 关闭相同号码对比模态框
            const closeSameNumbersModal = document.getElementById('closeSameNumbersModal');
            if (closeSameNumbersModal) {
                closeSameNumbersModal.addEventListener('click', function() {
                    document.getElementById('sameNumbersModal').classList.add('hidden');
                });
            }
            
            // 关闭相同号码对比模态框（标题栏按钮）
            const closeSameNumbersModalHeader = document.getElementById('closeSameNumbersModalHeader');
            if (closeSameNumbersModalHeader) {
                closeSameNumbersModalHeader.addEventListener('click', function() {
                    document.getElementById('sameNumbersModal').classList.add('hidden');
                });
            }
            
            // 位置走势图期数选择变化事件
            const positionChartPeriods = document.getElementById('positionChartPeriods');
            if (positionChartPeriods) {
                positionChartPeriods.addEventListener('change', function() {
                    const numPeriods = this.value === 'all' ? localState.kl8HistoryData?.length || 20 : parseInt(this.value);
                    updateAllPositionCharts(numPeriods);
                });
            }
            
            // 位置走势图更新按钮事件
            const updateAllChartsBtn = document.getElementById('updateAllChartsBtn');
            if (updateAllChartsBtn) {
                updateAllChartsBtn.addEventListener('click', function() {
                    const positionChartPeriods = document.getElementById('positionChartPeriods');
                    const numPeriods = positionChartPeriods?.value === 'all' ? 
                        localState.kl8HistoryData?.length || 20 : 
                        parseInt(positionChartPeriods?.value || '20');
                    updateAllPositionCharts(numPeriods);
                });
            }
            
            // 关闭预测对比模态框
            document.getElementById('closePredictionComparisonModal').addEventListener('click', function() {
                document.getElementById('predictionComparisonModal').classList.add('hidden');
            });
            
            // 关闭预测对比模态框（标题栏按钮）
            document.getElementById('closePredictionComparisonModalHeader').addEventListener('click', function() {
                document.getElementById('predictionComparisonModal').classList.add('hidden');
            });
        }
        
        // 计算历史数据相同号码对比
        function calculateSameNumbersFrequency() {
            if (!localState.kl8HistoryData || localState.kl8HistoryData.length < 2) {
                showNotification('历史数据不足，无法进行对比分析', 'error');
                return;
            }
            
            // 获取最新一期数据
            const latestPeriod = localState.kl8HistoryData[0];
            const latestNumbers = new Set(latestPeriod.numbers);
            
            // 准备统计结果
            const sameNumbersStats = [];
            
            // 与历史各期进行对比
            for (let i = 1; i < localState.kl8HistoryData.length; i++) {
                const historicalPeriod = localState.kl8HistoryData[i];
                let sameCount = 0;
                
                // 计算相同号码数量
                for (const num of historicalPeriod.numbers) {
                    if (latestNumbers.has(num)) {
                        sameCount++;
                    }
                }
                
                // 计算相同号码频率
                const frequency = (sameCount / 20 * 100).toFixed(1);
                
                sameNumbersStats.push({
                    period: historicalPeriod.period,
                    sameCount: sameCount,
                    frequency: parseFloat(frequency),
                    sameNumbers: historicalPeriod.numbers.filter(num => latestNumbers.has(num))
                });
            }
            
            // 按相同号码数量降序排序
            sameNumbersStats.sort((a, b) => b.sameCount - a.sameCount);
            
            // 渲染对比结果
            renderSameNumbersFrequency(latestPeriod, sameNumbersStats);
        }
        
        // 渲染相同号码频率对比结果
        function renderSameNumbersFrequency(latestPeriod, stats) {
            const contentElement = document.getElementById('sameNumbersContent');
            if (!contentElement) return;
            
            // 计算总体统计
            const maxSameCount = stats.length > 0 ? stats[0].sameCount : 0;
            const avgSameCount = stats.length > 0 ? (stats.reduce((sum, item) => sum + item.sameCount, 0) / stats.length).toFixed(2) : 0;
            const maxFrequency = stats.length > 0 ? stats[0].frequency.toFixed(1) : 0;
            
            let html = `
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-2">总体统计</h3>
                    <div class="grid grid-cols-3 gap-4">
                        <div class="bg-blue-50 p-4 rounded-lg">
                            <p class="text-sm text-blue-700 mb-1">最大相同号码数</p>
                            <p class="text-2xl font-bold text-blue-900">${maxSameCount}</p>
                        </div>
                        <div class="bg-green-50 p-4 rounded-lg">
                            <p class="text-sm text-green-700 mb-1">平均相同号码数</p>
                            <p class="text-2xl font-bold text-green-900">${avgSameCount}</p>
                        </div>
                        <div class="bg-purple-50 p-4 rounded-lg">
                            <p class="text-sm text-purple-700 mb-1">最高相同频率</p>
                            <p class="text-2xl font-bold text-purple-900">${maxFrequency}%</p>
                        </div>
                    </div>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-4">最新一期 (${latestPeriod.period})</h3>
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <div class="flex flex-wrap gap-2 mb-3">`;
            
            // 渲染最新一期号码球
            latestPeriod.numbers.forEach(number => {
                let ballClass = 'bg-blue-100 text-blue-600';
                const num = parseInt(number);
                
                if (num > 20 && num <= 40) ballClass = 'bg-green-100 text-green-600';
                else if (num > 40 && num <= 60) ballClass = 'bg-yellow-100 text-yellow-600';
                else if (num > 60) ballClass = 'bg-red-100 text-red-600';
                
                html += `
                    <div class="${ballClass} w-10 h-10 rounded-full flex items-center justify-center font-medium">
                        ${number}
                    </div>
                `;
            });
            
            html += `
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold mb-4">历史数据相同号码对比 (最多显示30条)</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white rounded-lg overflow-hidden">
                            <thead class="bg-gray-100">
                                <tr>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">期号</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">相同号码数</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">相同频率</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">相同号码</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-200">
            `;
            
            // 添加各期的对比数据（最多显示30条）
            const displayStats = stats.slice(0, 30);
            displayStats.forEach((stat, index) => {
                // 根据相同频率设置颜色
                let frequencyColor = 'text-blue-600';
                if (stat.frequency > 30) frequencyColor = 'text-green-600';
                if (stat.frequency > 50) frequencyColor = 'text-yellow-600';
                if (stat.frequency > 70) frequencyColor = 'text-red-600';
                
                // 生成相同号码的HTML
                let sameNumbersHtml = '';
                stat.sameNumbers.forEach(number => {
                    let ballClass = 'bg-blue-100 text-blue-600';
                    const num = parseInt(number);
                    
                    if (num > 20 && num <= 40) ballClass = 'bg-green-100 text-green-600';
                    else if (num > 40 && num <= 60) ballClass = 'bg-yellow-100 text-yellow-600';
                    else if (num > 60) ballClass = 'bg-red-100 text-red-600';
                    
                    sameNumbersHtml += `
                        <div class="${ballClass} w-8 h-8 rounded-full flex items-center justify-center font-medium text-sm mr-1 mb-1">
                            ${number}
                        </div>
                    `;
                });
                
                html += `
                    <tr class="hover:bg-gray-50">
                        <td class="px-4 py-3 text-sm text-gray-900">${stat.period}</td>
                        <td class="px-4 py-3 text-sm text-gray-900">${stat.sameCount}</td>
                        <td class="px-4 py-3 text-sm ${frequencyColor} font-medium">${stat.frequency}%</td>
                        <td class="px-4 py-3 text-sm text-gray-900">
                            <div class="flex flex-wrap">${sameNumbersHtml}</div>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            contentElement.innerHTML = html;
            
            // 显示模态框
            document.getElementById('sameNumbersModal').classList.remove('hidden');
        }
        
        // 比较预测号码和开奖号码
        function comparePredictionWithResult(prediction, actualNumbers) {
            // 转换为集合以便快速查找
            const actualSet = new Set(actualNumbers);
            
            // 分类预测号码
            const matchedNumbers = [];  // 命中的号码
            const missedNumbers = [];   // 未命中的号码
            
            // 检查每个预测号码是否命中
            prediction.predictedNumbers.forEach(num => {
                if (actualSet.has(num)) {
                    matchedNumbers.push(num);
                } else {
                    missedNumbers.push(num);
                }
            });
            
            // 计算命中统计
            const totalPredicted = prediction.predictedNumbers.length;
            const matchedCount = matchedNumbers.length;
            const accuracy = totalPredicted > 0 ? (matchedCount / totalPredicted * 100).toFixed(2) : 0;
            
            // 计算遗漏的开奖号码
            const missedActualNumbers = actualNumbers.filter(num => !prediction.predictedNumbers.includes(num));
            
            return {
                prediction: prediction,
                actualNumbers: actualNumbers,
                matchedNumbers: matchedNumbers,
                matchedCount: matchedCount,
                missedNumbers: missedNumbers,
                missedActualNumbers: missedActualNumbers,
                accuracy: parseFloat(accuracy),
                totalPredicted: totalPredicted
            };
        }
        
        // 生成改进建议
        function generateImprovementSuggestions(comparisonResult) {
            const suggestions = [];
            
            // 基于准确率的建议
            if (comparisonResult.accuracy < 30) {
                suggestions.push("当前预测准确率较低，建议增加历史数据量以提高模型稳定性");
            } else if (comparisonResult.accuracy < 50) {
                suggestions.push("预测准确率中等，可以尝试调整预测算法参数");
            } else {
                suggestions.push("预测准确率良好，建议继续保持当前策略");
            }
            
            // 基于遗漏号码的分析
            const missedActualNumbers = comparisonResult.missedActualNumbers;
            if (missedActualNumbers.length > 10) {
                const recentFrequency = calculateNumberFrequencyInRecentDraws(missedActualNumbers, 5);
                const hotNumbers = recentFrequency.filter(item => item.frequency > 1);
                
                if (hotNumbers.length > 3) {
                    suggestions.push(`发现${hotNumbers.length}个热门号码被遗漏，建议下次预测时考虑这些号码: ${hotNumbers.slice(0, 5).map(item => item.number).join(', ')}`);
                }
            }
            
            // 基于分区的建议
            const partitionStats = analyzeNumberPartitions(comparisonResult.prediction.predictedNumbers);
            const actualPartitionStats = analyzeNumberPartitions(comparisonResult.actualNumbers);
            
            for (let i = 0; i < partitionStats.length; i++) {
                const predictedCount = partitionStats[i].count;
                const actualCount = actualPartitionStats[i].count;
                const difference = Math.abs(predictedCount - actualCount);
                
                if (difference > 4) {  // 差异较大
                    if (predictedCount > actualCount) {
                        suggestions.push(`分区 ${partitionStats[i].name} 预测过多，实际只开出${actualCount}个号码，建议减少该区间预测数量`);
                    } else {
                        suggestions.push(`分区 ${partitionStats[i].name} 预测过少，实际开出${actualCount}个号码，建议增加该区间预测数量`);
                    }
                }
            }
            
            return suggestions;
        }
        
        // 计算号码在最近几期的出现频率
        function calculateNumberFrequencyInRecentDraws(numbers, periodCount) {
            if (!localState.kl8HistoryData || localState.kl8HistoryData.length === 0) {
                return [];
            }
            
            // 限制期数
            const recentPeriods = localState.kl8HistoryData.slice(0, Math.min(periodCount, localState.kl8HistoryData.length));
            
            // 统计每个号码的出现次数
            const frequencyMap = {};
            numbers.forEach(num => {
                frequencyMap[num] = 0;
            });
            
            recentPeriods.forEach(period => {
                period.numbers.forEach(num => {
                    if (frequencyMap[num] !== undefined) {
                        frequencyMap[num]++;
                    }
                });
            });
            
            // 转换为数组并排序
            return Object.entries(frequencyMap)
                .map(([number, frequency]) => ({ number, frequency }))
                .sort((a, b) => b.frequency - a.frequency);
        }
        
        // 分析号码分区统计
        function analyzeNumberPartitions(numbers) {
            const partitions = [
                { name: "1-20", range: [1, 20], count: 0 },
                { name: "21-40", range: [21, 40], count: 0 },
                { name: "41-60", range: [41, 60], count: 0 },
                { name: "61-80", range: [61, 80], count: 0 }
            ];
            
            numbers.forEach(numStr => {
                const num = parseInt(numStr);
                for (const partition of partitions) {
                    if (num >= partition.range[0] && num <= partition.range[1]) {
                        partition.count++;
                        break;
                    }
                }
            });
            
            return partitions;
        }
        
        // 渲染预测与开奖号码对比结果
        function renderPredictionComparison(comparisonResult, suggestions) {
            const contentElement = document.getElementById('predictionComparisonContent');
            if (!contentElement) return;
            
            let html = `
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-2">预测详情</h3>
                    <div class="grid grid-cols-3 gap-4">
                        <div class="bg-blue-50 p-4 rounded-lg">
                            <p class="text-sm text-blue-700 mb-1">预测时间</p>
                            <p class="text-xl font-bold text-blue-900">${new Date(comparisonResult.prediction.timestamp).toLocaleString('zh-CN')}</p>
                        </div>
                        <div class="bg-green-50 p-4 rounded-lg">
                            <p class="text-sm text-green-700 mb-1">预测方法</p>
                            <p class="text-xl font-bold text-green-900">${getMethodDisplayName(comparisonResult.prediction.method)}</p>
                        </div>
                        <div class="bg-purple-50 p-4 rounded-lg">
                            <p class="text-sm text-purple-700 mb-1">预测准确率</p>
                            <p class="text-xl font-bold text-purple-900">${comparisonResult.accuracy}%</p>
                        </div>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <!-- 预测号码 -->
                    <div>
                        <h3 class="text-lg font-semibold mb-4">预测号码</h3>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <div class="flex flex-wrap gap-2 mb-3">
            `;
            
            // 渲染预测号码球（命中的高亮显示）
            comparisonResult.prediction.predictedNumbers.forEach(number => {
                let ballClass = 'bg-gray-100 text-gray-600';
                const num = parseInt(number);
                
                if (comparisonResult.matchedNumbers.includes(number)) {
                    // 命中的号码使用特殊颜色
                    ballClass = 'bg-green-100 text-green-600 border-2 border-green-400';
                } else {
                    // 未命中的号码使用常规颜色
                    if (num > 20 && num <= 40) ballClass = 'bg-gray-100 text-gray-600';
                    else if (num > 40 && num <= 60) ballClass = 'bg-gray-100 text-gray-600';
                    else if (num > 60) ballClass = 'bg-gray-100 text-gray-600';
                }
                
                html += `
                    <div class="${ballClass} w-10 h-10 rounded-full flex items-center justify-center font-medium">
                        ${number}
                    </div>
                `;
            });
            
            html += `
                            </div>
                        </div>
                    </div>
                    
                    <!-- 开奖号码 -->
                    <div>
                        <h3 class="text-lg font-semibold mb-4">开奖号码</h3>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <div class="flex flex-wrap gap-2 mb-3">
            `;
            
            // 渲染开奖号码球（预测命中的高亮显示）
            comparisonResult.actualNumbers.forEach(number => {
                let ballClass = 'bg-blue-100 text-blue-600';
                const num = parseInt(number);
                
                if (comparisonResult.matchedNumbers.includes(number)) {
                    // 被预测命中的号码使用特殊颜色
                    ballClass = 'bg-green-100 text-green-600 border-2 border-green-400';
                } else {
                    // 未被预测命中的号码使用常规颜色
                    if (num > 20 && num <= 40) ballClass = 'bg-green-100 text-green-600';
                    else if (num > 40 && num <= 60) ballClass = 'bg-yellow-100 text-yellow-600';
                    else if (num > 60) ballClass = 'bg-red-100 text-red-600';
                }
                
                html += `
                    <div class="${ballClass} w-10 h-10 rounded-full flex items-center justify-center font-medium">
                        ${number}
                    </div>
                `;
            });
            
            html += `
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <!-- 命中号码 -->
                    <div>
                        <h3 class="text-lg font-semibold mb-4">命中号码 (${comparisonResult.matchedCount}个)</h3>
                        <div class="bg-green-50 p-4 rounded-lg">
                            <div class="flex flex-wrap gap-2">
            `;
            
            // 渲染命中号码
            if (comparisonResult.matchedNumbers.length > 0) {
                comparisonResult.matchedNumbers.forEach(number => {
                    html += `
                        <div class="bg-green-100 text-green-600 w-10 h-10 rounded-full flex items-center justify-center font-medium">
                            ${number}
                        </div>
                    `;
                });
            } else {
                html += `<p class="text-gray-500">暂无命中号码</p>`;
            }
            
            html += `
                            </div>
                        </div>
                    </div>
                    
                    <!-- 遗漏的开奖号码 -->
                    <div>
                        <h3 class="text-lg font-semibold mb-4">遗漏的开奖号码 (${comparisonResult.missedActualNumbers.length}个)</h3>
                        <div class="bg-yellow-50 p-4 rounded-lg">
                            <div class="flex flex-wrap gap-2">
            `;
            
            // 渲染遗漏的开奖号码
            comparisonResult.missedActualNumbers.slice(0, 20).forEach(number => {
                let ballClass = 'bg-blue-100 text-blue-600';
                const num = parseInt(number);
                
                if (num > 20 && num <= 40) ballClass = 'bg-green-100 text-green-600';
                else if (num > 40 && num <= 60) ballClass = 'bg-yellow-100 text-yellow-600';
                else if (num > 60) ballClass = 'bg-red-100 text-red-600';
                
                html += `
                    <div class="${ballClass} w-8 h-8 rounded-full flex items-center justify-center font-medium text-sm">
                        ${number}
                    </div>
                `;
            });
            
            html += `
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 分区分析 -->
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-4">分区分析</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white rounded-lg overflow-hidden">
                            <thead class="bg-gray-100">
                                <tr>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">分区</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">预测数量</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">实际数量</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-700">差异</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-200">
            `;
            
            // 渲染分区统计
            const predictedPartitions = analyzeNumberPartitions(comparisonResult.prediction.predictedNumbers);
            const actualPartitions = analyzeNumberPartitions(comparisonResult.actualNumbers);
            
            for (let i = 0; i < predictedPartitions.length; i++) {
                const predicted = predictedPartitions[i];
                const actual = actualPartitions[i];
                const difference = Math.abs(predicted.count - actual.count);
                let diffClass = 'text-gray-600';
                
                if (difference > 4) diffClass = 'text-red-600';
                else if (difference > 2) diffClass = 'text-yellow-600';
                
                html += `
                    <tr class="hover:bg-gray-50">
                        <td class="px-4 py-3 text-sm text-gray-900">${predicted.name}</td>
                        <td class="px-4 py-3 text-sm text-gray-900">${predicted.count}</td>
                        <td class="px-4 py-3 text-sm text-gray-900">${actual.count}</td>
                        <td class="px-4 py-3 text-sm ${diffClass} font-medium">${difference}</td>
                    </tr>
                `;
            }
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- 改进建议 -->
                <div>
                    <h3 class="text-lg font-semibold mb-4">预测改进建议</h3>
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <ul class="list-disc pl-5 space-y-2">
            `;
            
            // 渲染改进建议
            if (suggestions.length > 0) {
                suggestions.forEach(suggestion => {
                    html += `<li class="text-blue-800">${suggestion}</li>`;
                });
            } else {
                html += `<li class="text-gray-500">暂无建议</li>`;
            }
            
            html += `
                        </ul>
                    </div>
                </div>
            `;
            
            contentElement.innerHTML = html;
            
            // 显示模态框
            document.getElementById('predictionComparisonModal').classList.remove('hidden');
        }
        
        // 显示预测与开奖号码对比（已实现，无需重复定义）
        
        // 初始化页面
        function initPage() {
            // 初始化事件监听器
            bindEventListeners();
            initEventListeners();
            
            // 加载历史数据
            loadKl8HistoryData();
            
            // 使用setTimeout确保在数据加载后再初始化走势图
            setTimeout(() => {
                initPositionCharts();
                
                // 添加另一个延迟，确保图表初始化完成后再强制刷新，以应用我们的修改
                setTimeout(() => {
                    if (window.forceRefreshCharts) {
                        console.log('在页面初始化后强制刷新所有位置图表');
                        window.forceRefreshCharts();
                    }
                }, 200);
            }, 100);
        }
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', initPage);
    </script>
    
    <!-- 数据对比模态框 -->
    <div id="dataComparisonModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl max-w-5xl w-full max-h-[90vh] overflow-auto">
            <div class="p-5 border-b border-gray-200 flex justify-between items-center">
                <h2 class="text-xl font-bold text-dark">预测数据对比分析</h2>
                <button id="closeComparisonModalHeader" class="text-gray-400 hover:text-gray-500 focus:outline-none" title="关闭数据对比">
                    <i class="fa fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-5">
                <div id="comparisonContent">
                    <!-- 对比内容将通过JavaScript动态生成 -->
                </div>
            </div>
            <div class="p-5 border-t border-gray-200 flex justify-end space-x-3">
                <button id="exportComparisonReport" class="bg-success hover:bg-success/90 text-white px-4 py-2 rounded-md transition-all">
                    <i class="fa fa-download mr-1"></i> 导出报告
                </button>
                <button id="closeComparisonModal" class="bg-gray-200 hover:bg-gray-300 text-dark px-4 py-2 rounded-md transition-all" title="关闭数据对比">
                    关闭
                </button>
            </div>
        </div>
    </div>
    
    <!-- 相同号码对比模态框 -->
    <div id="sameNumbersModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl max-w-5xl w-full max-h-[90vh] overflow-auto">
            <div class="p-5 border-b border-gray-200 flex justify-between items-center">
                <h2 class="text-xl font-bold text-dark">历史数据相同号码对比</h2>
                <button id="closeSameNumbersModalHeader" class="text-gray-400 hover:text-gray-500 focus:outline-none" title="关闭">
                    <i class="fa fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-5">
                <div id="sameNumbersContent">
                    <!-- 内容将通过JavaScript动态生成 -->
                    <div class="flex items-center justify-center h-40 text-gray-400">
                        <i class="fa fa-spinner fa-spin mr-2"></i> 加载中...
                    </div>
                </div>
            </div>
            <div class="p-5 border-t border-gray-200 flex justify-end">
                <button id="closeSameNumbersModal" class="bg-gray-200 hover:bg-gray-300 text-dark px-4 py-2 rounded-md transition-all" title="关闭">
                    关闭
                </button>
            </div>
        </div>
    </div>
    
    <!-- 预测号码和开奖号码对比模态框 -->
    <div id="predictionComparisonModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl max-w-5xl w-full max-h-[90vh] overflow-auto">
            <div class="p-5 border-b border-gray-200 flex justify-between items-center">
                <h2 class="text-xl font-bold text-dark">预测号码与开奖号码对比分析</h2>
                <button id="closePredictionComparisonModalHeader" class="text-gray-400 hover:text-gray-500 focus:outline-none" title="关闭">
                    <i class="fa fa-times text-xl"></i>
                </button>
            </div>
            <div class="p-5">
                <div id="predictionComparisonContent">
                    <!-- 内容将通过JavaScript动态生成 -->
                    <div class="flex items-center justify-center h-40 text-gray-400">
                        <i class="fa fa-spinner fa-spin mr-2"></i> 加载中...
                    </div>
                </div>
            </div>
            <div class="p-5 border-t border-gray-200 flex justify-end">
                <button id="closePredictionComparisonModal" class="bg-gray-200 hover:bg-gray-300 text-dark px-4 py-2 rounded-md transition-all" title="关闭">
                    关闭
                </button>
            </div>
        </div>
    </div>
    
    <!-- 显示同期预测号码和开奖号码对比 -->
    <script>
    function showPeriodPredictionComparison() {
        const predictionHistory = loadPredictionHistory();
        const recentDraws = localState.kl8HistoryData || [];
        
        console.log('预测历史记录数量:', predictionHistory.length);
        console.log('开奖数据数量:', recentDraws.length);
        
        if (predictionHistory.length === 0) {
            showNotification('暂无预测历史记录', 'warning');
            return;
        }
        
        if (recentDraws.length === 0) {
            showNotification('暂无开奖数据', 'warning');
            return;
        }
        
        // 获取所有有预测记录的期号
        const periodsWithPredictions = [...new Set(predictionHistory.map(p => p.period).filter(Boolean))];
        const periodsWithDraws = [...new Set(recentDraws.map(d => d.period))];
        
        console.log('预测记录期号:', periodsWithPredictions);
        console.log('开奖数据期号:', periodsWithDraws);
        
        // 找到同时有预测和开奖的期号
        const commonPeriods = periodsWithPredictions.filter(p => periodsWithDraws.includes(p));
        
        console.log('同期期号:', commonPeriods);
        
        const modal = document.getElementById('predictionComparisonModal');
        const content = document.getElementById('predictionComparisonContent');
        
        // 确保模态框存在
        if (!modal || !content) {
            console.error('未找到预测对比模态框元素');
            showNotification('系统错误：未找到对比界面元素', 'error');
            return;
        }
        
        // 立即显示模态框，避免内容加载后忘记显示
        modal.classList.remove('hidden');
        
        if (commonPeriods.length === 0) {
            // 即使没有完全匹配的期号，也提供一个"立即对比"的选项
            // 使用最新的预测和最新的开奖结果进行对比
            const latestPrediction = predictionHistory[0];
            const latestDraw = recentDraws[0];
            
            let comparisonHtml = `
                <div class="text-center p-8">
                    <p class="text-gray-500 mb-4">暂无同期的预测记录和开奖数据</p>
                    <p class="text-gray-400 text-sm mb-6">请确保预测记录和开奖数据使用相同的期号格式</p>
            `;
            
            if (latestPrediction && latestDraw) {
                comparisonHtml += `
                    <div class="bg-blue-50 p-4 rounded-lg mb-6">
                        <h4 class="font-medium text-blue-800 mb-2">快速对比</h4>
                        <p class="text-sm text-gray-600 mb-4">使用最新的预测和开奖结果进行对比分析</p>
                        <button id="quickComparisonBtn" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors">
                            立即对比
                        </button>
                    </div>
                    <div class="text-xs text-gray-400">
                        <p>最新预测期号: ${latestPrediction.period}</p>
                        <p>最新开奖期号: ${latestDraw.period}</p>
                    </div>
                `;
            }
            
            comparisonHtml += `</div>`;
            content.innerHTML = comparisonHtml;
            
            // 添加立即对比按钮的事件监听
            const quickBtn = document.getElementById('quickComparisonBtn');
            if (quickBtn) {
                quickBtn.onclick = () => {
                    // 创建一个临时的对比视图
                    const quickComparisonHtml = generateQuickComparisonView(latestPrediction, latestDraw);
                    content.innerHTML = quickComparisonHtml;
                };
            }
        } else {
            // 生成期号选择界面
            content.innerHTML = `
                <div class="space-y-6">
                    <div class="bg-blue-50 p-4 rounded-md">
                        <h3 class="text-lg font-medium text-blue-800 mb-2">选择对比期号</h3>
                        <p class="text-blue-700 text-sm">以下期号同时有预测记录和开奖数据</p>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                        ${commonPeriods.map(period => `
                            <div class="border rounded-md p-4 hover:shadow-md transition-shadow cursor-pointer bg-white" onclick="comparePeriodPredictions('${period}')">
                                <div class="flex items-center justify-between">
                                    <span class="font-medium">期号: ${period}</span>
                                    <button class="bg-primary text-white px-3 py-1 rounded text-sm">
                                        查看对比
                                    </button>
                                </div>
                                <div class="mt-2 text-sm text-gray-500">
                                    <span>预测记录: ${predictionHistory.filter(p => p.period === period).length}条</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        modal.classList.remove('hidden');
        
        // 简化关闭逻辑，使用函数引用避免重复绑定
        const closeModal = () => {
            modal.classList.add('hidden');
        };
        
        // 确保获取到关闭按钮元素后再绑定事件
        const headerCloseBtn = document.getElementById('closePredictionComparisonModalHeader');
        const footerCloseBtn = document.getElementById('closePredictionComparisonModal');
        
        if (headerCloseBtn) headerCloseBtn.onclick = closeModal;
        if (footerCloseBtn) footerCloseBtn.onclick = closeModal;
        
        // 点击模态框外部关闭
        modal.onclick = (e) => {
            if (e.target === modal) {
                closeModal();
            }
        };
    }
    
    // 计算预测与开奖结果的对比
    function comparePredictionWithResult(predictedNumbers, actualNumbers) {
        console.log('对比预测号码:', predictedNumbers);
        console.log('实际开奖号码:', actualNumbers);
        
        const matchedNumbers = [];
        const unmatchedNumbers = [];
        
        // 确保都是数字类型并正确比较
        const actualNumbersSet = new Set(actualNumbers.map(n => Number(n)));
        
        predictedNumbers.forEach(num => {
            const numAsNumber = Number(num);
            console.log(`检查数字 ${num} 是否在开奖结果中:`, actualNumbersSet.has(numAsNumber));
            if (actualNumbersSet.has(numAsNumber)) {
                matchedNumbers.push(numAsNumber);
            } else {
                unmatchedNumbers.push(numAsNumber);
            }
        });
        
        console.log('匹配结果:', matchedNumbers);
        console.log('未匹配结果:', unmatchedNumbers);
        
        // 安全计算准确率，避免除以零
        const accuracy = predictedNumbers.length > 0 ? 
            Math.round((matchedNumbers.length / predictedNumbers.length) * 100) : 0;
            
        console.log('计算准确率:', accuracy);
        
        return {
            matchedNumbers,
            unmatchedNumbers,
            accuracy,
            matchedCount: matchedNumbers.length
        };
    }
    
    // 保存预测对比结果到历史记录
    function savePredictionComparisonResult(predictionId, drawResult) {
        // 查找对应的预测记录
        const prediction = localState.predictionHistory.find(p => p.id === predictionId);
        if (!prediction) {
            console.error('未找到预测记录:', predictionId);
            return false;
        }
        
        // 进行号码对比
        const comparison = comparePredictionWithResult(prediction.numbers, drawResult.numbers);
        
        // 更新预测记录的准确率和正确数量
        prediction.correctCount = comparison.matchedCount;
        prediction.accuracy = comparison.accuracy + '%';
        prediction.actualNumbers = drawResult.numbers;
        prediction.comparisonDate = new Date().toLocaleString('zh-CN');
        
        // 保存更新后的历史记录
        savePredictionHistory();
        updateHistoryTable();
        
        console.log('预测对比结果已保存:', prediction);
        return true;
    }
    
    // 分析号码分区
    function analyzeNumberPartitions(predictedNumbers, actualNumbers) {
        const partitions = [
            { name: '小号 (1-16)', min: 1, max: 16 },
            { name: '大号 (17-32)', min: 17, max: 32 },
            { name: '奇数', isOdd: true },
            { name: '偶数', isEven: true }
        ];
        
        return partitions.map(partition => {
            const predicted = predictedNumbers.filter(num => {
                if (partition.min !== undefined && partition.max !== undefined) {
                    return num >= partition.min && num <= partition.max;
                } else if (partition.isOdd) {
                    return num % 2 !== 0;
                } else if (partition.isEven) {
                    return num % 2 === 0;
                }
                return false;
            }).length;
            
            const actual = actualNumbers.filter(num => {
                if (partition.min !== undefined && partition.max !== undefined) {
                    return num >= partition.min && num <= partition.max;
                } else if (partition.isOdd) {
                    return num % 2 !== 0;
                } else if (partition.isEven) {
                    return num % 2 === 0;
                }
                return false;
            }).length;
            
            return {
                name: partition.name,
                predicted,
                actual,
                diff: predicted - actual
            };
        });
    }
    
    // 生成快速对比视图
    function generateQuickComparisonView(prediction, drawResult) {
        if (!prediction || !drawResult) {
            return '<div class="text-center p-8 text-red-500">数据不足，无法进行对比</div>';
        }
        
        // 使用已定义的对比函数
        const comparison = comparePredictionWithResult(prediction.numbers, drawResult.numbers);
        
        // 生成对比内容
        return `
            <div class="mb-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold">快速对比分析</h3>
                    <div class="bg-yellow-100 text-yellow-800 px-3 py-1 rounded text-sm">
                        注意：预测期号 ${prediction.period} 与开奖期号 ${drawResult.period} 不匹配
                    </div>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- 预测信息 -->
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <h4 class="font-medium text-blue-800 mb-3">预测信息</h4>
                        <div class="space-y-2 text-sm">
                            <div>预测方法: ${getMethodDisplayName(prediction.method)}</div>
                            <div>预测时间: ${prediction.timestamp}</div>
                            <div>预测期号: ${prediction.period}</div>
                        </div>
                        <div class="mt-3">
                            <div class="text-sm font-medium mb-2">预测号码</div>
                            <div class="flex flex-wrap gap-2">
                                ${prediction.numbers.map(num => {
                                    const isHit = comparison.matchedNumbers.includes(num);
                                    return `<span class="inline-flex items-center justify-center w-8 h-8 rounded-full font-bold ${isHit ? 'bg-green-600 text-white' : 'bg-gray-300 text-gray-800'}">${num}</span>`;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                    
                    <!-- 开奖信息 -->
                    <div class="bg-green-50 p-4 rounded-lg">
                        <h4 class="font-medium text-green-800 mb-3">开奖信息</h4>
                        <div class="space-y-2 text-sm">
                            <div>开奖期号: ${drawResult.period}</div>
                            <div>开奖时间: ${drawResult.timestamp || '未知'}</div>
                        </div>
                        <div class="mt-3">
                            <div class="text-sm font-medium mb-2">开奖号码</div>
                            <div class="flex flex-wrap gap-2">
                                ${drawResult.numbers.map(num => `<span class="inline-flex items-center justify-center w-8 h-8 bg-green-600 text-white rounded-full font-bold">${num}</span>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 对比分析 -->
            <div class="bg-white border rounded-lg p-5 mb-6">
                <h4 class="font-bold text-lg mb-4">对比分析结果</h4>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                    <div class="bg-blue-100 p-3 rounded-lg text-center">
                        <div class="text-sm text-blue-700">准确率</div>
                        <div class="text-2xl font-bold text-blue-900">${comparison.accuracy}%</div>
                    </div>
                    <div class="bg-green-100 p-3 rounded-lg text-center">
                        <div class="text-sm text-green-700">命中数量</div>
                        <div class="text-2xl font-bold text-green-900">${comparison.matchedNumbers.length}</div>
                    </div>
                    <div class="bg-red-100 p-3 rounded-lg text-center">
                        <div class="text-sm text-red-700">未命中数量</div>
                        <div class="text-2xl font-bold text-red-900">${comparison.unmatchedNumbers.length}</div>
                    </div>
                </div>
                
                <div class="space-y-4">
                    <div>
                        <h5 class="text-sm font-medium text-gray-700 mb-2">命中号码</h5>
                        <div class="flex flex-wrap gap-2">
                            ${comparison.matchedNumbers.length > 0 ? 
                                comparison.matchedNumbers.map(num => `<span class="inline-flex items-center justify-center w-8 h-8 bg-green-600 text-white rounded-full font-bold">${num}</span>`).join('') : 
                                '<span class="text-gray-400 italic">无</span>'
                            }
                        </div>
                    </div>
                    
                    <div>
                        <h5 class="text-sm font-medium text-gray-700 mb-2">未命中号码</h5>
                        <div class="flex flex-wrap gap-2">
                            ${comparison.unmatchedNumbers.map(num => `<span class="inline-flex items-center justify-center w-8 h-8 bg-gray-300 text-gray-800 rounded-full font-bold">${num}</span>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
            
            <button onclick="showPeriodPredictionComparison()" class="bg-gray-100 hover:bg-gray-200 text-gray-800 px-4 py-2 rounded-md transition-colors">
                返回期号选择
            </button>
        `;
    }
    
    // 对比指定期号的预测和开奖结果
        function comparePeriodPredictions(period) {
            console.log('对比期间:', period);
            
            const predictionHistory = loadPredictionHistory();
            const recentDraws = localState.kl8HistoryData || [];
            
            console.log('预测历史记录:', predictionHistory.length);
            console.log('开奖数据:', recentDraws.length);
            
            // 获取该期号的所有预测记录
            const periodPredictions = predictionHistory.filter(p => p.period === period);
            console.log('该期预测记录数量:', periodPredictions.length);
            
            // 获取该期号的开奖结果
            const drawResult = recentDraws.find(d => d.period === period);
            console.log('开奖结果:', drawResult);
            
            // 自动更新所有该期预测记录的对比结果
            periodPredictions.forEach(prediction => {
                if (!prediction.correctCount || !prediction.accuracy || prediction.accuracy === '--') {
                    savePredictionComparisonResult(prediction.id, drawResult);
                }
            });
        
        const content = document.getElementById('predictionComparisonContent');
        console.log('内容元素:', content);
        
        // 确保内容元素存在
        if (!content) {
            console.error('未找到预测对比内容元素');
            showNotification('系统错误：未找到内容显示区域', 'error');
            return;
        }
        
        if (!drawResult) {
            content.innerHTML = '<p class="text-center text-red-500 py-8">未找到该期的开奖结果</p>';
            return;
        }
        
        // 生成对比内容
        let comparisonHTML = `
            <div class="mb-6">
                <h3 class="text-xl font-bold mb-4">期号 ${period} 对比分析</h3>
                <div class="bg-green-50 p-4 rounded-md mb-4">
                    <h4 class="font-medium text-green-800 mb-2">开奖号码</h4>
                    <div class="flex flex-wrap gap-2">
                        ${drawResult.numbers.map(num => `
                            <span class="inline-flex items-center justify-center w-10 h-10 bg-green-600 text-white rounded-full font-bold">${num}</span>
                        `).join('')}
                    </div>
                </div>
            </div>
            <div class="space-y-6">
        `;
        
        // 为每个预测生成对比
        periodPredictions.forEach(prediction => {
            const comparison = comparePredictionWithResult(prediction.numbers, drawResult.numbers);
            
            comparisonHTML += `
                <div class="border rounded-lg p-5 bg-white shadow-sm">
                    <div class="flex justify-between items-start mb-4">
                        <div>
                            <h4 class="font-bold text-lg">预测方法: ${getMethodDisplayName(prediction.method)}</h4>
                            <p class="text-gray-500 text-sm">预测时间: ${prediction.timestamp}</p>
                        </div>
                        <div class="text-center bg-blue-100 text-blue-800 px-3 py-1 rounded">
                            <div class="text-sm">准确率</div>
                            <div class="font-bold text-lg">${comparison.accuracy}%</div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                        <!-- 预测号码 -->
                        <div>
                            <h5 class="text-sm font-medium text-gray-700 mb-2">预测号码</h5>
                            <div class="flex flex-wrap gap-2">
                                ${prediction.numbers.map(num => {
                                    const isHit = comparison.matchedNumbers.includes(num);
                                    return `<span class="inline-flex items-center justify-center w-10 h-10 rounded-full font-bold ${isHit ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-800'}">${num}</span>`;
                                }).join('')}
                            </div>
                        </div>
                        
                        <!-- 命中分析 -->
                        <div>
                            <h5 class="text-sm font-medium text-gray-700 mb-2">命中分析</h5>
                            <div class="space-y-3">
                                <div class="flex items-center justify-between">
                                    <span class="text-sm">命中号码:</span>
                                    <span class="font-medium">${comparison.matchedNumbers.length}/${prediction.numbers.length}</span>
                                </div>
                                <div class="flex items-center justify-between">
                                    <span class="text-sm">未命中号码:</span>
                                    <span class="font-medium">${comparison.unmatchedNumbers.length}/${prediction.numbers.length}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 分区分析 -->
                    <div>
                        <h5 class="text-sm font-medium text-gray-700 mb-2">分区分析</h5>
                        <table class="min-w-full bg-white border border-gray-200">
                            <thead>
                                <tr>
                                    <th class="py-2 px-4 border-b text-left text-xs font-medium text-gray-500 uppercase tracking-wider">分区</th>
                                    <th class="py-2 px-4 border-b text-left text-xs font-medium text-gray-500 uppercase tracking-wider">预测数量</th>
                                    <th class="py-2 px-4 border-b text-left text-xs font-medium text-gray-500 uppercase tracking-wider">实际数量</th>
                                    <th class="py-2 px-4 border-b text-left text-xs font-medium text-gray-500 uppercase tracking-wider">差异</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${analyzeNumberPartitions(prediction.numbers, drawResult.numbers).map(partition => `
                                    <tr>
                                        <td class="py-2 px-4 border-b">${partition.name}</td>
                                        <td class="py-2 px-4 border-b">${partition.predicted}</td>
                                        <td class="py-2 px-4 border-b">${partition.actual}</td>
                                        <td class="py-2 px-4 border-b ${Math.abs(partition.diff) > 1 ? 'text-red-500' : 'text-green-500'}">${partition.diff > 0 ? '+' : ''}${partition.diff}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        });
        
        comparisonHTML += '</div>';
        content.innerHTML = comparisonHTML;
    }
    // 诊断对比功能问题的调试函数
    function debugPredictionComparison() {
        console.log('=== 预测对比功能调试信息 ===');
        
        // 检查数据状态
        const predictionHistory = loadPredictionHistory();
        const recentDraws = localState.kl8HistoryData || [];
        
        console.log('预测历史记录数量:', predictionHistory.length);
        console.log('开奖数据数量:', recentDraws.length);
        
        if (predictionHistory.length > 0) {
            console.log('最新预测记录示例:', predictionHistory[0]);
            // 获取所有预测的期号
            const predictionPeriods = [...new Set(predictionHistory.map(p => p.period).filter(Boolean))];
            console.log('预测记录期号列表:', predictionPeriods);
        }
        
        if (recentDraws.length > 0) {
            console.log('最新开奖数据示例:', recentDraws[0]);
            // 获取所有开奖的期号
            const drawPeriods = [...new Set(recentDraws.map(d => d.period))];
            console.log('开奖数据期号列表:', drawPeriods);
            
            // 检查是否有匹配的期号
            if (predictionHistory.length > 0) {
                const predictionPeriods = [...new Set(predictionHistory.map(p => p.period).filter(Boolean))];
                const drawPeriods = [...new Set(recentDraws.map(d => d.period))];
                const commonPeriods = predictionPeriods.filter(p => drawPeriods.includes(p));
                
                console.log('匹配的期号数量:', commonPeriods.length);
                console.log('匹配的期号列表:', commonPeriods);
                
                // 如果有匹配期号，尝试直接显示第一个匹配期号的对比
                if (commonPeriods.length > 0) {
                    console.log('尝试直接显示第一个匹配期号的对比:', commonPeriods[0]);
                    try {
                        comparePeriodPredictions(commonPeriods[0]);
                        console.log('成功调用comparePeriodPredictions函数');
                    } catch (error) {
                        console.error('调用comparePeriodPredictions函数出错:', error);
                    }
                }
            }
        }
        
        // 检查DOM元素
        console.log('模态框元素:', document.getElementById('predictionComparisonModal'));
        console.log('内容区域元素:', document.getElementById('predictionComparisonContent'));
        
        // 检查辅助函数是否正确实现
        try {
            const testNumbers1 = [1, 2, 3, 4, 5];
            const testNumbers2 = [1, 3, 5, 7, 9];
            const testComparison = comparePredictionWithResult(testNumbers1, testNumbers2);
            console.log('测试对比函数结果:', testComparison);
            
            const testPartitions = analyzeNumberPartitions(testNumbers1, testNumbers2);
            console.log('测试分区分析函数结果:', testPartitions);
        } catch (error) {
            console.error('辅助函数测试失败:', error);
        }
        
        // 最后显示模态框
        console.log('尝试显示模态框');
        const modal = document.getElementById('predictionComparisonModal');
        if (modal) {
            modal.classList.remove('hidden');
            // 尝试执行原始的对比显示函数
            showPeriodPredictionComparison();
            console.log('已调用showPeriodPredictionComparison函数');
        }
        
        console.log('=== 调试完成 ===');
    }
    
    // 为调试按钮添加点击事件
    document.getElementById('debugPredictionButton').addEventListener('click', function() {
        console.log('调试按钮被点击，开始诊断预测对比功能...');
        
        // 先执行核心修复，确保对比功能可以显示
        console.log('执行核心修复...');
        fixPredictionComparison();
        
        // 然后执行详细诊断
        console.log('执行详细诊断...');
        debugPredictionComparison();
        
        // 最后提示用户
        alert('预测对比功能已尝试修复。请查看页面上的对比结果，并检查浏览器控制台以获取详细诊断信息。');
    });
    
    // 自动修复和更新所有预测记录的对比结果
    function updateAllPredictionComparisons() {
        console.log('开始更新所有预测记录的对比结果...');
        
        const predictionHistory = loadPredictionHistory();
        const recentDraws = localState.kl8HistoryData || [];
        
        if (predictionHistory.length === 0) {
            console.log('没有预测历史记录，无法更新');
            return 0;
        }
        
        let updatedCount = 0;
        let fixedCount = 0;
        let notFoundCount = 0;
        
        // 创建开奖结果的映射，方便快速查找
        const drawByPeriod = {};
        recentDraws.forEach(draw => {
            drawByPeriod[draw.period] = draw;
        });
        
        // 统计使用随机数据的记录
        const randomDataRecords = predictionHistory.filter(p => 
            p.accuracy && !p.comparisonDate && !p.actualNumbers
        );
        console.log(`发现 ${randomDataRecords.length} 条可能使用随机数据的历史记录需要修复`);
        
        // 遍历所有预测记录
        predictionHistory.forEach(prediction => {
            // 检查是否为随机生成的数据（没有comparisonDate和actualNumbers但有accuracy）
            if (prediction.accuracy && !prediction.comparisonDate && !prediction.actualNumbers) {
                // 清除旧的随机数据
                prediction.accuracy = null;
                prediction.correctCount = null;
                fixedCount++;
            }
            
            // 如果有预测期号，尝试查找对应的开奖结果
            if (prediction.period) {
                if (drawByPeriod[prediction.period]) {
                    // 如果预测记录还没有准确率数据，或者需要重新计算
                    if (!prediction.correctCount || !prediction.accuracy) {
                        const drawResult = drawByPeriod[prediction.period];
                        const comparison = comparePredictionWithResult(prediction.numbers, drawResult.numbers);
                        
                        // 更新预测记录为真实数据
                        prediction.correctCount = comparison.matchedCount;
                        prediction.accuracy = comparison.accuracy + '%';
                        prediction.actualNumbers = drawResult.numbers;
                        prediction.comparisonDate = new Date().toLocaleString('zh-CN');
                        prediction.randomGenerated = false; // 标记为非随机生成
                        
                        updatedCount++;
                    }
                } else {
                    notFoundCount++;
                }
            }
        });
        
        // 保存更新后的历史记录
        savePredictionHistory();
        updateHistoryTable();
        
        console.log(`预测记录更新完成: 更新 ${updatedCount} 条记录, 修复 ${fixedCount} 条随机数据, 未找到对应开奖数据 ${notFoundCount} 条记录`);
        
        return {
            updated: updatedCount,
            fixed: fixedCount,
            totalRecords: predictionHistory.length
        };
    }
    
    // 核心修复函数 - 确保预测对比功能正常工作
    function fixPredictionComparison() {
        // 先更新所有预测记录的对比结果
        const result = updateAllPredictionComparisons();
        
        // 显示修复结果
        const content = document.getElementById('predictionComparisonContent');
        if (content) {
            // 显示修复结果和测试对比内容
            content.innerHTML = `
                <div class="mb-6">
                    <h3 class="text-lg font-semibold mb-4">预测对比功能修复结果</h3>
                    <p class="text-green-600 mb-2">✅ 已成功将随机生成的预测结果替换为真实对比数据</p>
                    <p class="mb-1">📊 总预测记录数: <strong>${result.totalRecords}</strong></p>
                    <p class="mb-1">🔄 更新的预测记录: <strong>${result.updated}</strong></p>
                    <p class="mb-1">🔧 修复的随机数据: <strong>${result.fixed}</strong></p>
                    <p class="mb-4">❓ 未找到开奖数据: <strong>${result.totalRecords - result.updated}</strong></p>
                    <p class="text-sm text-gray-600">历史预测记录现在使用真实的开奖号码进行对比分析，确保数据准确性。</p>
                    <div class="bg-green-50 border border-green-200 p-4 rounded-lg mb-4">
                        <p>已更新 ${result.updated} 条预测记录的对比结果</p>
                    </div>
                    
                    <div class="mb-4">
                        <h4 class="font-medium mb-2">测试预测号码:</h4>
                        <div class="flex flex-wrap gap-2">
                            <div class="bg-green-100 text-green-800 px-3 py-1 rounded-full">1</div>
                            <div class="bg-green-100 text-green-800 px-3 py-1 rounded-full">3</div>
                            <div class="bg-green-100 text-green-800 px-3 py-1 rounded-full">5</div>
                            <div class="bg-gray-100 text-gray-600 px-3 py-1 rounded-full">7</div>
                            <div class="bg-gray-100 text-gray-600 px-3 py-1 rounded-full">9</div>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <h4 class="font-medium mb-2">测试开奖号码:</h4>
                        <div class="flex flex-wrap gap-2">
                            <div class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full">1</div>
                            <div class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full">3</div>
                            <div class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full">5</div>
                            <div class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full">11</div>
                            <div class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full">13</div>
                        </div>
                    </div>
                    
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <p class="font-medium mb-2">命中分析结果:</p>
                        <p>准确率: 60.0%</p>
                        <p>命中: 3个 | 未命中: 2个</p>
                    </div>
                </div>
            `;
        }
        
        // 确保模态框可见
        const modal = document.getElementById('predictionComparisonModal');
        if (modal) {
            modal.classList.remove('hidden');
        }
        
        return true;
    }
    </script>
</body>
</html>
